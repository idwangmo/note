错题笔记：

JSP内置对象和属性列举如下：

1.request对象

     客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。

2.response对象

     response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。

3.session对象

     session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.

4.out对象

     out对象是JspWriter类的实例,是向客户端输出内容常用的对象

5.page对象

     page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例

6.application对象

     application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。

7.exception对象

   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象

8.pageContext对象

pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。

9.config对象

config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

---

一个算法应该具有以下五个重要的特征：

### 有穷性

（Finiteness）

算法的有穷性是指算法必须能在执行有限个步骤之后终止；

### 确切性

(Definiteness)

算法的每一步骤必须有确切的定义；

### 输入项

(Input)

一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；

### 输出项

(Output)

一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；

### 可行性

(Effectiveness)

算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。



s为null，因此只要调用了s.length()都会抛出空指针异常。因此这个题目就是考察if语句的后半部分会不会执行。
A，单个与操作的符号& 用在整数上是按位与，用在布尔型变量上跟&&功能类似，但是区别是无论前面是否为真，后面必定执行，因此抛出异常
B，与操作，前半部分判断为假，后面不再执行
C，这里跟 & 和&& 的区别类似，后面必定执行，因此抛出异常
D，或语句，前面为真，整个结果必定为真，后面不执行

---

List 可以通过下标 (1,2..) 来取得值，值可以重复,而 Set 只能通过游标来取值，并且值是不能重复的

ArrayList ， Vector ， LinkedList 是 List 的实现类

ArrayList 是线程不安全的， Vector 是线程安全的，这两个类底层都是由数组实现的

LinkedList 是线程不安全的，底层是由链表实现的

------

Map 是键值对集合

HashTable 和 HashMap 是 Map 的实现类

HashTable 是线程安全的，不能存储 null 值

HashMap 不是线程安全的，可以存储 null 值

---

### Java锁的种类以及辨析 锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现(如 synchronized 和 ReentrantLock等等 ) 。这些已经写好提供的锁为我们开发提供了便利，但是锁的具体性质以及类型却很少被提及。本系列文章将分析JAVA中常见的锁以及其特性，为大家答疑解惑。

### [1、自旋锁](http://ifeve.com/java_lock_see1/)

### [2、自旋锁的其他种类](http://ifeve.com/java_lock_see2/)

### [3、阻塞锁](http://ifeve.com/java_lock_see3/)

### 4、可重入锁

### 5、读写锁

### 6、互斥锁

### 7、悲观锁

### 8、乐观锁

### 9、公平锁

### 10、非公平锁

### 11、偏向锁

### 12、对象锁

### 13、线程锁

### 14、锁粗化

### 15、轻量级锁

### 16、锁消除

### 17、锁膨胀

### 18、信号量

---

垃圾回收在jvm中优先级相当相当低。

B：垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。

C：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。

D：进入DEAD的线程，它还可以恢复，GC不会回收

---

Java 把内存划分成两种：一种是栈内存，另一种是堆内存。

在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。

数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。

---

Java中的多线程是一种抢占式的机制，而不是分时机制。抢占式的机制是有多个线程处于可运行状态，但是只有一个线程在运行。 
**共同点** **：** 
\1. 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 
\2. wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。 
如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。 
需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。 
**不同点** **： ** 
1.每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。 
sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 
2.wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 
3.sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 

4.sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。

5.wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

---

**public Method[] getDeclaredMethods()**返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。

**public Method[] getMethods()**返回某个类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。

---

Statement是sql语句的载体

Statement是标准的Statement类，通过字符串对sql语句进行拼接，但是它存在sql注入的危险

PreparedStatement对sql语句进行了预编译，可以防止SQL注入

CallableStatement用来调用存储过程的

BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类

---

Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。

(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet

(2)创建：通过调用servlet构造函数创建一个servlet对象

(3)初始化：调用init方法初始化

(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求

(5)卸载：调用destroy方法让servlet自己释放其占用的资源

---

类变量既可以通过类来返回，也可以通过类的对象来访问。但通过类的对象来访问类变量时，实际不是访问该对象所拥有的变量，因为当系统创建该类的对象时，系统不会再为类变量分配内存，也不会再次对类变量进行初始化，也就是说，对象根本不拥有对应类的类变量，通过对象访问类变量只是一种假象，通过对象访问的依然是该类的类变量。 ————《疯狂java讲义》

---

Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。

throw用于抛出异常。

throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。

try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。

cacth用于捕获从try中抛出的异常并作出处理。

finally语句块是不管有没有出现异常都要执行的内容。

---

含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class

类中定义抽象方法必须在具体

(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

下面比较一下两者的语法区别：

1.抽象类可以有构造方法，接口中不能有构造方法。

2.抽象类中可以有普通成员变量，接口中没有普通成员变量

3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

\4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然

eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

\5. 抽象类中可以包含静态方法，接口中不能包含静态方法

\6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。