# 第一章

Unix系统具有的特点：

* 简单性
* 集中性
* 可重用组件
* 过滤器
* 开放的文件格式
* 灵活性

Linux应用程序表现为两种特殊类型的文件：可执行文件和脚本文件。

文件系统属性用来指明一个文件是否为可执行的程序。

从PATH中删除目录并不是一个好主意，除非确信你了解这么做的后果。

库是一组预先编译好的函数集合，这些函数都是按照可重用原则编写的。

库文件类型：

* `.a`代表传统的静态函数库
* `.so`代表共享函数库

通过gcc编译器的`-c`选项来阻止编译期创建一个完整的程序。

使用ar程序可以创建一个归档文件并将你的目标文件添加进去。

可以使用`-l`选项来访问函数库，但因为其为保存在标准位置，所有必须使用`-L`选项来告诉编译期在什么地方找到它。

静态库的一个缺点是，当同时运行许多应用程序并且它们都使用来自同一个函数库的函数时，内存中就会有同一函数的多份副本，而且在程序文件本身中也有多份同样的副本。

当一个程序使用共享库时，它的链接方式是这样的：程序本身不在包含函数代码，而是引用运行时可访问的共享代码。当编译好的程序被装载到内存中执行时，函数引用被解析并产生对共享库的调用，如果有必要，共享课才被加载到内存。

共享库的更新可以独立于依赖它的应用程序。

`info`系统的有点是，你可以通过链接和教材引用来浏览文档并可以直接跳转到相关的章节。

# 二 Shell程序设计

## 基础

shell非常适合编写一些执行相对简单的任务和小工具，因为它们更强调的是易于配置，易于维护和可移植性，而不是很看重执行的效率。

Unix架构非常依赖于代码的高等可重用性。

shell是一个作为用户与Linux系统间接的程序。它允许用户向操作系统输入需要执行的命令。

文件描述符0代表一个程序的标准输入，文件描述符1代表标准输出，而文件描述符2代表标准错误输出。重定向时候，默认情况下，如果该文件已经存在，它的内容将被覆盖。如果想改变默认行为，可以使用命令`set -o noclobber`命令来措置重定向操作对一个已有文件的覆盖，用`set +o noclobber`命令来取消。

可以用`>>`操作符将输出内容附加到一个文件中。

可以使用Linux的通用“回收站”`/dev/null`来有效地丢弃所有的输出信息。

在Linux下通过管道连接的进程可以同时运行，并且随着数据流在它们之间的传递可以自动地进行协调。

如果有一系列的命令需要执行，相应的输出文件是在这一组命令被创建的同时立刻被创建或写入的，所有绝不要在命令流中重复使用相同的文件名。

shell本身只是允许你将几个现有的命令结合在一起，以构成一个新的功能强大的命令。

`#!`字符告诉系统同一行上紧跟在它后面的那个参数是用来执行本文件的程序。

当程序使用交互方式运行时，我们很少需要检查它的退出码，但如果打算从另一个脚本程序里调用这个脚本程序并查看它师傅执行成功，那么返回一个适当的退出码就很重要了。

在shell程序设计里，0表示成功。

执行脚本文件：

* 调用shell，并把脚本文件当成一个参数
* 或使用`chomd`命令来改变这个文件的模式，使得这个文件可以被所有用户执行

在linux中，如果你拥有包含某个文件的目录的写权限，就可以删除这个文件。

## shell的语法

### 变量

使用变量之前通常不需要事先为他们做出声明，默认情况下，所有变量都被看做字符串并以字符串来储存，及时它们被赋值为数值时也是如此。

Linux是一个区分大小写的系统。

可以通过在变量名前加一个`$`符来访问它的内容，无论何时你想要获取变量的内容，都必须在它前加一个`$`符。

> 赋值时不加`$`符，使用时加`$`符

**如果字符中包含空格，就必须用引号把它们括起来，等号两边不能有空格。**

可以使用`read`命令将用户的输入赋值给一个变量。

一般情况下，脚本文件中的参数以空白字符分隔，如果想在一个参数中包含一个或多个空白字符，就必须给参数加上引号。

![环境变量](..\image\环境变量.png)

如果脚本程序在调用时带有参数，一些额外的变量就会被创建，即使没有传递任何参数，环境变量`$#`也依然存在，只不过它的值是0罢了。

![参数变量](..\image\参数变量.png)

## 条件

所有程序设计语言的基础是对条件进行测试判断，并根据测试结果采取不同行动的能力。

一个shell脚本能对任何可以从命令行上调用的命令的退出码进行测试，其中也包括自己编写的脚本程序。

格式：

```shell
if ...
then
...
fi
```

if和then连写时：

```shell
if ... ; then
...
fi
```

`test`命令可以使用的条件类型可以归为3类：字符比较、算术比较和文件有关的条件测试。

`set-uid`位授予了程序其拥有者的访问权限而不是其使用者的访问权限，而`set-gid`位授予了程序其所在组的访问权限。但这两个标志位对shell脚本程序不起作用，它们只对可执行的二进制文件有用。

各种与文件有关的条件测试的结果为真的前提是文件必须存在。

## 控制结果

### if语句

```shell
if condition
then
	statements
else
	statements
fi
```

### elif语句

```shell
if condition
then
	statements
elif
	statements
else
	statements
fi
```



如果想让echo命令去掉后面的换行符，可移植性最好的办法是使用`printf`命令而不是使用echo命令

### for语句

```shell
for variable in values
do
	statemnets
done
```

加上引号相当于告诉shell把引号之间的一切东西都看作一个字符串。

### while语句

```shell
while condition do
  statements
done
```

### until语句

```shell
until condition
do
  statements
done
```

此循环测试将反复执行直到条件为真，而不是在条件为真时反复执行。

如果需要循环至少执行一次，那么就使用while循环；如果可能根本都不需要执行循环，就使用until循环。

### case语句

```shell
case variable in
  pattern [ | pattern ] ...) statements;;
  pattern [ | pattern ] ...) statements;;
  ...
esac
```

case结构运行通过使用一种比较复杂的方式将变量的内容和模式进行匹配，然后再根据匹配模式去执行不同的代码。

case将使用提一个匹配的模式，即使后续的模式有更加精确的匹配也是如此。

### 命令列表

#### AND列表

只有在前面所有的命令都执行成功的情况下才执后一条命令。

语法为：

```shell
statement1 && statement2 && statement3 && ...
```

> 具有短路效果

每条语句都是独立的执行，这运行把多个不同的指令混合在一个单独的命令列表中。

#### OR列表

允许我们持续执行一系列命令知道有一条命令成功为止，其后的命令将不再被执行。

```shell
statement1 || statement2 || ...
```

只需要执行最少的语句就可以确定其返回结果。

#### 语句块

如果在某个只允许使用单个语句的地方使用多条语句，可以把它们扩在花括号中`{}`。

### 函数

```shell
fuction_name () {
  statements
}
```

### 命令

1. 普通命令——外置命令
2. 内置命令——内部命令

#### break命令

在控制条件为满足之前，跳出for、while或until循环。

#### `：`命令

#### continue命令

使for、while或until循环跳到下一次循环继续执行

#### `.`命令

此命令在当前shell中执行命令

在默认情况下，shell脚本程序会在一个新创建的环境中执行，所有脚本程序对环境变量所做的任何修改都会丢失，而点命令允许执行的脚本程序改变当前环境

#### echo命令

建议在现代shell中使用printf命令来输出结尾带有换行符的字符串

#### eval命令

允许对参数进行求值

#### exec命令

* 将当前shell替换为一个不同的程序
* 修改当前文件描述符

#### exit命令

使脚本程序与退出码n结束允许。

如果脚本程序在退出时不指定一个退出状态，那么该脚本最后一条被执行命令的状态将被用做返回值。在脚本程序中提供一个退出码总是一个良好的编程习惯。

#### exprot命令

将作为它参数的变量导出到子shell中，并使之在子shell中有效。

在默认情况下，在一个shell中被创建的变量在这个shell调用的下级shell中是不可用的。

export命令把自己的参数创建为一个环境变量，而这个环境变量可以被当前程序调用的其他脚本程序看见。

#### expr命令

将它的参数当做一个表达式来求值

#### printf命令

用来提代`echo`

#### return命令

函数返回值

#### set命令

为shell设置参数变量

#### shift命令

其将所有参数变量左移一个位置如使`$2`变成`$1`

#### trap命令

用于指定在接收到信号后将要采取的行动。

其一种常见的用途是在脚本程序被中断时完成清理工作。

脚本程序通常是以从上到下的顺序解释执行的，所有必须在想保护的那部分代码之前指定trap命令。

#### unset命令

从环境中删除变量或函数

#### find命令

```shell
find [path] [options] [tests] [actions]
```

#### grep命令令

```shell
grep [options] PATTERN [FILES]
```

使用find命令在系统中搜索文件，而使用grep指令在文件中搜索字符串。常见的做法是在使用find命令时，将grep作为传递给`-exec`的一条命令

#### here文档

向一条命令传递输入的一种特殊的方法。它允许一条命令在获得输入数据时就好像是在读取一个文件或键盘一样，而实际上是从脚本程序中得到输入数据。

### 命令的执行

可以执行一条命令，并把该买哪个领导 输出放到一个变量中

1. 算术扩展：将准备求值的表达式扩在`$((...))`中能够更有效的完成简单的算术运算
2. 参数扩展：

因为UNIX和Linux系统都非常依赖过滤器的思想，所有一个操作的结果常常必须手工进行重定向

## dialog

一个图形化的工具

# 第三章 文件操作

**一切都是文件**

目录是用于保存其他文件的结点号和名字的文件。删除一个文件实际上是删除了该文件对应的目录项，同时指向该文件的链接数减1。文件被包含在目录中，目录中可能还包含子目录。

标准库文件并不能理解文件名参数中的shell波浪线速记符号，所有必须始终在自己的程序中使用真实的文件名。

## 重要的设备文件：

1. `/dev/console`：代表系统控制台。错误信息和诊断信息通常会发到这个设备。
2. `/dev/tty`：如果有一个进程有控制终端的话，那么特殊文件`/dev/tty`就是这个控制终端的别名。
3. `/dev/null`：所有写入这个设备的输出都将被丢弃，而读这个设备则立刻返回一个文件尾标示符。

设备被分为字符设备和块设备。两者区别在于访问设备时是否需要一次读写一整块。

为了向用户提供一个一致的接口，设备驱动程序封装了所有与硬件相关的特性。硬件的特有功能通常可以通过ioctl系统调用来提供。

## 访问设备驱动程序的底层函数

* open：打开设备或文件,为了创建一个新的文件描述符
* read：从打开的文件或设备中读取数据，从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放回到数据区buf中
* write：向文件或设备写数据，把缓冲区buf前nbytes个字节写入与文件描述符fildes关联的文件中
* close：关闭文件或设备，终止文件描述符fildes与其对应文件之间的关联。文件描述符被释放并能重新使用
* ioctl：把控制台信息传递给设备驱动程序，提供了一个用于控制设备及其描述符行为和配置底层服务的接口。

**针对输入操作直接使用系统底层调用的一个问题是它们的效率非常低**：

1. 使用系统调用会影响系统的性能
2. 硬件会限制对底层系统调用一次所能读写的数据块大小

每个运行中的程序被称为进程，它有一些与之关联的文件描述符。

write可能会报告写入的字节比你要求的少，这并不是一个错误，在程序中，需要检查errno以发现错误，然后再次调用write写入剩余的数据。

### write调用

```c
#include <unistd.h>

size_t write(int fildes, const void *buf, size_t nbytes);
```

### reaad调用

```c
#include <unistd.h>

size_t read(int fildes, void *buf, size_t nbytes);
```

### open调用

```c
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

int open(const char *path, int oflags);
int open(const char *path, int oflags, mode_t mode);
```

open建立了一条文件或设备的访问路径，成功则返回一个可以被read、write和其他系统调用使用的文件描述符，这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。

open在调用成功时返回一个新的文件描述符，在失败时返回-1并设置全局变量errno来指明失败的原因。新的文件描述符总是使用未用描述符的最小值。

### close调用

```c
#include <unistd.h>

int close(int filds);
```

**检查close调用的返回结果非常重要**

### ioctl调用

```c
#include <unistd.h>

int ioctl(int fildes, int cmd, ...);
```

### 访问权限和初始值

当使用带有O_CREAT标志的open调用来创建文件时，必须使用3个参数格式的open调用，第三个参数mode是几个标志按位或后得到的：

 ![权限](..\image\权限.png)

open调用里给出的摩的值将于当时的用户掩码的反值做AND操作

#### umask

当文件被创建时，为文件的访问权限设定一个掩码。

## 与文件关联相关的系统调用

### lseek系统调用

对文件描述符fildes的读写指针进行设置。

```c
#include <unistd.h>
#include <sys/types.h>

off_t lseek(int fildes, off_t offset, int whence);
```

offest指定位置，whence定义该偏移值的用法。whence取值：

* SEEK_SET：offset是一个绝对位置
* SEEK_CUR：offset是一个对于当前位置的一个相对位置
* SEEK_END：offset是一个对于文件尾的一个相对位置

### fstat，stat和lstat系统调用

fstat返回与大打开文件描述符相关的文件的状态信息，该信息将会写到一个buf结果中，buf的地址以参数的形式传递给fstat。stat和lstat返回的是该符号链接本身的信息。当文件是一个符号链接时，

```c
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

int fstat(int fildes, struct stat *buf);
int stat(const char *path, struct stat *buf);
int lstat(const chat *path, struct stat *buf);
```

### dup和dup2

dup系统调用提供了一种复制文件描述符的方法，使我们能够通过两个或者更多个不同的描述符来访问同一个文件。