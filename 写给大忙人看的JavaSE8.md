# 一 lambda表达式

java8主要实在原来面向对象的基础上增加了函数式编程的能力

“lambda表达式”是一段可以传递的代码，因此它可以被执行一次或多次

一段代码会被传递给其他调用者——也许是一个线程池、一个排序方法或者是一个按钮

如果一个语言包含了所有可以略微简化代码的特性，那么它就会变得不可维护

## lambda表达式语法

java是一个强类型语言，必须同时指定类型

java中lambda表达式的格式：参数、箭头->，以及一个表达式。如果负责计算的代码无法用一个表达式表示，那么可以用编写方法的方式来编写：急用{}包裹代码并明确使用return语句，如果不含参数，则直接使用()来代替参数；如果一个lambda表达式的参数类型是可以被推导的，那么就可以省略它们的类型；如果某个方法只包含一个参数，并且该参数的类型可以被推导出来，则可以省略小括号；永远不需要为一个lambda表达式执行返回类型，它总是会从上下文中被推导出来

## 函数式接口

对于只包含一个抽象方法的接口，可以通过lambda表达式来创建该接口的对象，这种接口被称为函数式接口

最好将一个lambda表达式想象成一个函数，而不是一个对象，并记住它可以被转换为一个函数式接口

函数式接口转换是在java中使用lambda表达式能做的唯一一件事

当希望使用lambda表达式时，仍然要 记住表达式的目的，并为它指定一个函数式接口

任何一个lambda表达式都可以等价转换成现在所使用的API中对应的函数式接口

可以在任意函数式接口上标注`@FunctionalInterface`注解，该注解并不要求强制使用，。从概念上讲，所有只包含有一个抽象方法的接口都是函数式接口，但是使用`@FunctionalInterface`注解会让代码看上去清楚

如果lambda表达式中可能会抛出一个检查前异常，那么该异常需要在目标接口的抽象方法中进行声明。一种是在lambda表达式中捕获异常，另一种是将lambda表达式赋给一个抽象方法可以抛出异常的接口

## 方法引用

```java
button.setOnAction(event -> System.out.println(event));
//等价于
buttom.setOnAction(System.out::println);
```

`::`操作符将方法名和对象或类的名字分隔开来，其主要三种使用情况：

* 对象::实例方法
* 类::静态方法
* 类::实例方法

在前两种情况中，方法引用等同于提供方法参数的lambda表达式。在第三种情况中，第一个参数会成为执行方法的对象

如果有多个同名的重载方法，编译器试图从上下文中找到最匹配的一个方法

在匿名类中，可以调用一个闭合类或父类的员工方法

## 构造器引用

`Button::new`表示对Button类的构造器引用。对于拥有多个构造器的类，选择使用哪个构造器取决于上下文

可以使用数组类型来编写构造器引用：如`int[]::new`是一个含有一个参数的构造器引用。数组构造器引用可以用来绕过Java中无法构造一个泛型类型T的数组

## 变量作用域

能够在lambda表达式的闭合方法或类中访问其他的变量

一个lambda表达式包括三个部分：

1. 一段代码
2. 参数
3. 自由变量值，这里的“自由“指的是那些不是参数并且没有在代码中定义的变量

可以将一个lambda表达式转换为一个只包含一个方法的对象，这样自由变量的值就会被复制到该对象的实例变量中

在lambda表达式中，被引用的变量的值不可以被更改

更改lambda表达式中的变量不是线程安全的

在java8之前，内部类只允许访问final的局部变量，为类适应lambda表达式，一个内部类可以访问任何有效的final局部变量——即任何值不会发生变化的变量

一个有效的final变量被初始化后，就永远不会再被赋予一个新值的变量

lambda表达式的方法体于嵌套代码块有着相同的作用域

当在lambda表达式中使用this关键字时，会引用创建该lambda表达式的方法的this参数

## 默认方法

默认方法终结了以前的一种经典模式，即提供一个接口，以及一个实现接口的大多数或全部方法的抽象类

如果一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法，选择：

1. 选择父类中的方法
2. 接口冲突

## 接口中的静态方法

Java8中的静态接口方法：

```java
// 构造含有n个o类型实例的列表
public static <T> List<T> nCopies(int n, T o)
```

虽然java的集合类不太可能像这样进行重构，但是你实现自己的库时，不必再为工具方法提供一个辅助的类了

# 二 Stream API

## 从迭代器到Stream操作

Stream是Java8中处理集合关键抽象概念，它可以指定你希望对集合进行的操作，但是将执行操作的时间交给具体的实现来决定

Stream与集合的区别：

1. Stream自己不会存储元素。元素可能被存储在底层的集合中，或者根据需要产生出来
2. Stream操作符不会改变源对象。相反，它们会返回一个持有结果的新Stream
3. Stream操作符可能是延迟操作的

Stream遵循“做什么，而不是怎么去做”的原则

当使用Stream时，会通过三个阶段来建立一个流水线操作

1. 创建一个Stream
2. 在一个或多个步骤中，指定将初始Stream转换为另外一个Stream的中间操作
3. 使用一个终止造作来产生一个结果

Stream操作不会按照元素的调用顺序执行

## 创建Stream

通过Java8 在Collection接口中新添加的stream方法，可以将任何集合转换为一份Steam。如果面对的是一个数组，也可以用静态的`Stream.of`方法将它转换为一个Stream

使用`Arrays.stream(array, from, to)`方法将数组的一部分转换为Stream

要创建一个不包含任何元素的Stream，可以使用静态的`Stream.empty`方法

Stream接口有两个用来创建无限Stream的静态方法：

1. generate方法接受一个无参数的函数 
2. iterate方法接受一个“种子（seed）”值和一个函数

当某个Stream上调用close方法时，底层的文件也会被关闭，为了确保关闭文件，最好使用Java7中提供的`try-with-resources`语句

## filter、map和flatMap方法

流转换是指从一个流中读取数据，并将转换后的数据写入到另一个流中国



