# 第一章

每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。

一个设计模式有四个基本要素：

1. 模式名称
2. 问题
3. 解决方案
4. 效果

设计模式是用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。

MVC通过建立一个”订购/通知“协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。

将对象分离，使得一个对象的改变能改影响另一些对象，而这个对象并不需要知道哪些被影响的对象细节。

MVC的另一个特征是视图可以嵌套。

将一些对象划为一组，并将该组对象当作一个对象使用。

MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式。

MVC的主要关心还是由Observe、Composite好Strategy三个设计模式给出的。

## 23个设计模式

Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

Adapter：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于借口哦不兼容而不能在一起工作的那些类可以一起工作。

Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

Chain of Reponsibility：为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。

Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以支持可取消的操作。

Composite：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。

Decorator：动态地给一个对象添加一写额外的职责。

Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

Factory Method：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。

Interpreter：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的子句。

Iterator：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存状态。

Observer：定义对象的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得得到通知并自动刷新。

Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

Proxy：为其他对象提供一个代理以控制这个对象的访问。

Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点

State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类

Strategy：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换

Template Method：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

Visitor：表示一个作用于某对象结构中的各元素的操作。可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

**插入设计模式空间图片**

模式可以根据其目的分为创建型、结构型、或行为型。

类模式处理子类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。

创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的认为。

设计模式解决的问题方法：

* 寻找合适的对象
* 决定对象的细粒度
* 指定对象接口
* 描述对象的实现

对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的**型构**

对象操作所定义的所有操作型构的集合被称为该对象的**接口**

**类型**是用来标识特定接口的一个名字

当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的**子类型**，另一个类型称为**超类型**

发送给对象的请求和它的相应操作在运行时刻的连接就称为**动态绑定**

对象通过实例化类来创建的，次对象被称为该类的实例。当实例化类时，要给对象的内部数据（由实例变量组成）分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来创建的。

新的类可以由已存在的类通过继承来定义。当子类继承父类时，子类包含该了父类所有的数据和操作。子类的实例对象包含所有子类和父类定义的数据，且它们能完成子类和父类定义的所有操作。

抽象类的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延迟加载到子类中，因此一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作。

类能够重定义父类定义的操作，重定义使得子类能接管父类对请求的处理操作。

混入类时给其他类提供可选择的接口或功能的类。

**对接口编程，而不是对实现编程**

面向对象系统中功能复用的两种最常用的技术是类继承和对象组合

**优先使用对象组合，而不是类继承**

导致重新设计的一般原因：

1. 通过显示地指定一个类来创建对象
2. 对特殊操作的依赖
3. 对硬件和软件平台的依赖
4. 对对象表示或实现的依赖
5. 算法依赖
6. 紧耦合
7. 通过生成子类来扩充功能
8. 不能方便的对类进行修改

模式和框架的区别：

1. 设计模式比框架更抽象
2. 设计模式是比框架更小的体系结构元素
3. 框架比设计模式更加特例化

选择设计模式的方法：

* 考虑设计模式是怎样解决设计问题的
* 浏览模式的意图部分
* 研究目的相似的模式
* 检查重新设计的原因
* 考虑设计中那些是可变的

# 第二章

层次结构信息的表述通常是通过一种被称为递归组合的技术来实现的。递归组合可以由较简单的元素逐渐建立复杂的元素。

获得跨越硬件和软件平台的可移植性是系统设计的主要问题之一。移植的一大障碍是不同视感标准之间的差异性。

一个平台将多个互相重叠的窗口展示在一个点阵显示器上。

图源抽象的一个重要作用就是隐藏了存储其子图源的数据结构，我们可以在不影响其他类的情况下改变图元的数据结构。

图元接口不应该偏重于某个数据结构。

一个好的解决方案是封装那些变化的概念。

分析对象怎样才能不使用类型测试或强制类型转换也能正确对待各种不同的图元。

# 第三章 创建型模式

创建型模式实例化了过程。

设计模式中两个不断出现的主旋律：

1. 它们都将关于该系统使用哪些具体的类的信息封装起来
2. 隐藏了这些类的实例是如何被创建和放在一起的

整个系统关于这些对象所知道的是由抽象类所定义的接口

## Abstract Factory（抽象工厂）——对象创建型模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

适用：

* 一个系统要独立于它是产品创建、组合和表示时
* 一个系统要由多个产品系列中的一个来配置时
* 当你要强调一系列相关的产品对象的设计以便进行联合适用时
* 提供一个产品类库，而只想显示它们的接口而不是实现时

优缺点：

1. 分离了具体的类
2. 使得易于交换产品系列
3. 有利于产品的一致性
4. 难以支持新种类的产品


一些实现：

1. 将工厂作为单件
2. 创建产品
3. 定义可扩展的工厂

一个具体的工厂通常是一个单件的

## Builder（生成器）——对象创建模型模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

每一个转换器类创建和装配一个复杂对象的机制隐含在抽象接口的后面。

适用：

* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时
* 当构造过程必须运行被构造的对象有不同表示时

效果：

1. 它使你可以改变一个产品的内部表示
2. 它将构造代码和表示代码分开
3. 它使你对构造过程进行更精细的控制

Builder模式着重于一步步构造一个复杂对象。而Factory Method着重于多个系列的产品对象。Builder在最后一步返回厂品，而对于Abstract Factory来说，产品是立即返回的。

## Factory Method（工厂方法）——对象创建型模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。

适用：

* 当一个类不知道它所必须创建的对象的类的时候、
* 当一个类希望由它的子类来指定它所创建的对象的时候
* 当类将创建对象的职责委托给多个帮助子类的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

效果：

1. 为子类提供挂钩
2. 连接评选的类层次

实现：

1. 主要两种不同的情况
   1. 是一个抽象类并且不提供它所声明的工厂方法的实现
   2. 是一个具体类而且为工厂方法提供一个缺省的实现
2. 参数化工厂方法
3. 特定语言的变化和问题
4. 使用模板以避免创建子类

## Prototype（原型）——对象创建型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

当一个系统应该独立于它的产品创建、构成和表示时，要用Prototype模式或

* 当要实例化的类是在运行时刻指定时
* 为了避免创建一个与产品类层次平行的工厂类层次时
* 当一个类的实例只能与几个不同状态组合中的一种时

优点：

1. 运行时刻增加和删除产品
2. 改变值以指定新对象
3. 改变结构以指定新对象
4. 减少子类构造
5. 用类动态配置应用

考虑的问题：

1. 使用一个原型管理器
2. 实现克隆操作
3. 初始化克隆对象


## Singleton（单件）——对象创建型模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

一个全局变量使得一个对象可以被访问，但它不能防止你实例化多个对象。一个更好的办法是让类自身负责保存它的唯一实例。

适用：

* 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时
* 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时

优点：

1. 对唯一实例的受控访问
2. 缩小名空间
3. 允许对操作和表示的精化
4. 允许可变数目的实例
5. 比类操作更灵活

问题：

1. 保证一个唯一实例
2. 创建类的子类

# 第四章 结构型模式

结构型模式涉及到如何组合类和对象已获得更大的结构。结构型类模式采用继承机制来组合接口实现。一个简单的例子是采用多重继承的方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。

适配器使得一个接口与其他接口兼容，从而给出了多个不同接口的统一抽象。

结构型模型不是对接口和实现的进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。

## Adapter（适配器）——类对象结构型模式

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类可以在一起工作。

适用：

* 想使用一个已经存在的类，而它的接口不符合你的需求
* 想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
* 想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口

考虑因素：

* Adapter的匹配程度
* 可插入的Adapter
* 使用双向适配器提供透明操作

最小接口集合仅包含两个操作：一个操作定义如何在层次结构中表示一个节点，另一个操作返回该节点的子节点。

对于窄接口的实现途径：

* 使用抽象操作
* 使用代理对象
* 参数化适配器


## Bridge（桥接）——对象结构型模式

将抽象部分和实现部分分离，使它们都可以独立地变化。

当一个抽象可能有多个实现时，通常用继承来协调它们。

继承机制使得客户代码与平台相关。

适用：

* 不希望在抽象和它的实现部分之间有一个固定的绑定关系
* 类的抽象以及它的实现部分都可以通过生成子类的方法加以扩充
* 对一个抽象的实现部分的修改应对客户不产生影响
* 对客户完全隐藏抽象的实现部分
* 在多个对象之间实现共享，但同时要求客户并不知道这一点
* 有许多类要生成

优点：

* 分离接口及其实现部分
* 提高可扩充性
* 实现细节对客户透明


## Composite（组合）——对象结构型模式

将对象组合成树形结构以表示“部分——整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

Composite模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。

适用：

* 想表示对象的部分-整体的层次结构
* 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

Composite模式：

* 定义了包含基本对象和组合的类层次结构
* 简化客户代码
* 使得更容易增加新类型的组件
* 使你的设计变得更加一般化

注意的问题：

* 显示的父部件引用
* 共享组件
* 最大化Component接口
* 声明管理子部件的操作
* Component是否应该实现一个Component列表
* 子部件排序
* 使用高速缓冲存贮改善性能
* 应该由谁删除Component
* 存贮组件最好用哪一种数据结构

仅当一个组件中增加或删除一个组件时，才改变这个组件的父部件。

## Decorator（装饰）——对象结构型模式

动态的给一个对象添加一些额外的职责。——包装器Wrapper

将组件嵌入到另一个对象中，我们称这个嵌入的对象为装饰。这个装饰与它所装饰的组件接口一致，因此它对该组件的客户透明。

适用：

* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责
* 处理那些可以撤销的职责
* 当不能采用生成子类的方法进行扩充时

优点和缺点：

* 比静态继承更灵活
* 避免在层次结构高层的类有太多的特征
* Decorator与它的Component不一样
* 有许多小对象

注意：

* 接口的一致性：装饰对象的接口必须与它所装饰的Component的接口一致
* 省略抽象的Decorator类
* 保持Component类的简单性：为了保证接口的一致性，组件和装饰必须有一个公共的Component父类
* 改变对象外壳与改变对象内核

## FACADE（外观）——对象结构型模式

为子系统中的一组接口提供一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

将一个系统划分为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。达到该目标的途径之一就是引入一个外观对象，它为子系统中较一般的设施提供了一个单一而简单的界面。

适用情况：

* 当你要为一个复杂子系统提供一个简单接口时
* 客户程序与抽象类的实现部分之间存在着很大的依赖性
* 当你需要构建一个层次结构的子系统时

客户程序通过发送请求给Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象。

使用Facade的客户程序不需要直接访问子系统对象。

优点：

* 对客户屏蔽了子系统组件，因而减少了客户处理对象的数目并使得子系统使用起来更加方便
* 实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是送紧合的
* 如果应用需要，它并不限制它们使用子系统类

注意：

* 降低客户-子系统之间的耦合度
* 公共子系统类与私有子系统类

## Flyweight（享元）——对象结构型模式

通用共享技术有效的支持大量细粒度的对象

flyweight不能对它所运行的场景做出任何假设，这里的关键概念是内部状态和外部状态之间的区别。

flyweight模式对那些通常因为数量太大而难以用对象来表示的概念或实体进行建模。

当以下情况都成立时使用：

* 一个应用程序使用了大量的对象
* 完全由于使用大量对象，造成很大的存储开销
* 对象的大多数状态都可以变为外部状态
* 如果删除对象的外部状态，那么可以用的相对较小的共享对象取代很多组对象
* 应用程序不依赖对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值

存储节约由一下几个因素决定：

* 因为共享，实例总数减少的数目
* 对象内部状态的平均数目
* 外部状态使计算还是存储的

节约存储的方法：

* 用共享减少内部状态的消耗
* 用计算时间换取对外部状态的存储

注意：

* 删除外部状态
* 管理共享对象

共享还意味着某种形式的引用计数和垃圾回收，这样当一个Flyweight不再使用时，可以回收它的存储空间。

## Proxy(代理)——对象结构型模式

对其他对象提供一种代理以控制这个对象的访问

使用Proxy模式的常见情况：

* 远程代理（Remote Proxy）为一个对象在不同的地址和空间提供局部代表——可以隐藏一个对象存在于不同地址空间的事实
* 虚代理（Virtual Proxy）根据需要创建开销很大的对象——可以进行最优化
* 保护代理（Protection Proxy）控制对原始对象的访问
* 只能引用（Smart Reference）取代了简单的指针。它在访问对象时执行一些附加操作

——运行在访问一个对象时有一些附加的内务处理

一般来说，所有操作在指向实体的转发请求之前，都要检验这个要求是否合法，原始对象是否存在等。

# 第五章 行为模式

行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。

行为类模式使用继承机制在类之间分派行为。

行为对象模式使用对象复合而不是继承。

其它行为模式常将行为封装在一个对象中并将请求指派给它。

## Chain Of Responsibility（职责链）——对象行为模式

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。

提交请求的对象并不明确地知道哪一个对象将会处理它——我们应该说请求有一个隐式的接受者

适用：

* 有多个对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定
* 你想在不明确指定接受者的情况下，向多个对象中的一个提交一个请求
* 可处理一个请求的对象集合应被动态指定

优缺点：

1. 降低耦合度
2. 增强了给对象指派职责的灵活性
3. 不保证被接受

考虑的问题：

1. 实现后继者链
   1. 定义新的链接
   2. 使用已有链接
2. 连接后继者
3. 表示请求

## Command（命令）——对象行为型模式

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。动作（Action）、事物（Transaction）

使用：

* 抽象出待执行的动作以参数化某个对象
* 在不同时刻指定、排列和执行请求
* 支持取消操作
* 支持修改日志
* 用构建在原语操作上的高层操作构造一个系统

效果：

* Command模式将调用操作的对象与知道如何实现该操作的对象解耦
* Command是头等对象。可以行其他对象一样被操作和扩展
* 可以将多个命令封装成一个复合命令
* 增加新的Command很容易，因为这无需改变已有的类

考虑问题：

* 一个命令对象应达到何种智能程度
* 支持取消(undo)和重做(redo)
* 避免取消操作过程中错误积累
* 使用C++模板

## Interpreter（解释器）——类行为型模式

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示解释语言中的句子

如果一种特定类型问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

效果最好的情况：

* 该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理
* 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式

优点和不足：

1. 易于改变和扩展文法
2. 也易于实现文法
3. 发杂的文法难以维护
4. 增加了新的解释表达式的方式

考虑的特殊问题：

1. 创建抽象语法树
2. 定义解释操作
3. 与Flyweight共享终结符

# Iterator（迭代器）——对象行为型模式

提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象内部表示——游标

将遍历机制与列表对象分离使我们可以定义不同的迭代器来实现不同的遍历策略，而无需在列表接口中列举它们。

适用：

* 访问一个聚合对象的内容而无需暴露它的内部表示
* 支持对聚合对象的多种遍历
* 为遍历不同的聚合结构提供统一的接口

作用：

1. 它支持以不同的方式遍历一个聚合
2. 迭代器简化了聚合的接口
3. 在同一个聚合上可以由多个遍历

实现：

1. 谁控制该迭代：由客户来控制迭代时，该迭代器称为一个外部迭代器，而当由迭代器控制迭代时，该迭代器称为内部迭代器
2. 谁定义遍历算法
3. 迭代器的健壮度如何

## Mediator（中介者）——对象行为模型

用一个中介来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互

面向对象鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。

适用：

* 一组对象以定义良好但复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
* 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象
* 想定制一个分布在多个类中的行为，而又不想生成太多的子类

优缺点：

1. 减少子类生成
2. 它将各Colleague解耦
3. 简化了对象协议
4. 对对象如何协作进行了抽象
5. 使控制集中化

## Memento（备忘录）——对象行为模式

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保证的状态。——Token

一个备忘录是一个对象，它存储另一个对象在某个瞬间的内部状态，而后者称为备忘录的原发器。

适用：

* 必须保存一个对象在某一个时刻的（部分）状态，这样以后需要它才能恢复到先前的状态
* 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性

效果：

1. 保持封装边界
2. 简化了原发器
3. 使用备忘录可能代价很高
4. 定义了窄接口和宽接口
5. 维护备忘录的潜在代价

## Observer（观察者）——对象行为型模式

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。

一个目标可以有任意数目的依赖它的观察者。一旦目标状态发生改变，所有观察者都得到通知。作为对这个通知的响应，每个观察者都将查询目标以使其状态与目标的状态同步。

适用：

* 当一个抽象模型有两个方面，一个方面依赖于另一个方面。将这二者封装在独立的对象中以使它们可以独自地改变和复用
* 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变
* 当一个对象必须通知其它对象，而他又不能假定其它对象是谁。

效果：

1. 目标和观察者之间的抽象耦合
2. 支持广播通信
3. 意外的更新

实现：

1. 创建目标到其观察者之间的映射关系
2. 观察多个目标
3. 谁触发更新
   1. 由目标对象的状态设定操作在改变目标对象的状态后自动调用Notify
   2. 让客户负责在适当的时候调用Notify
4. 对以删除目标的悬挂引用
5. 在发出通知前确保目标的状态自身是一致的
6. 避免特定于观察者的更新协议——推/拉模型
7. 显示的指定感兴趣的改变
8. 封装复杂的更新语义
9. 结合目标类和观察者类

## State（状态）——对象行为型模式

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

适用：

* 一个对象的行为取决于它的状态，并且它必须运行在运行时刻根据状态改变它的行为
* 一个操作中含有庞大的多分支的条件语句，而且这些分支依赖于该对象的状态

效果：

1. 它将与特定的状态相关的行为局部化，且将不同状态的行为分割开来
2. 使得状态转换显示化
3. State对象可被共享

实现：

1. 谁定义状态转换
2. 基于表的另一种方法
3. 创建和销毁State对象
4. 使用动态继承

## Strategy（策略）——对象行为型模式

定义一系列的算法，把它们一个个封装起来，并且他们可以相互替换。本模式使得算法可独立于使用它的客户而变化

适用：

* 许多相关类仅仅是行为有异
* 需要使用一个算法的不同变体
* 算法使用客户不应该知道是数据
* 一个类定义了多种行为

优缺点：

1. 相关算法系列
2. 一个替代集成的的方法
3. 消除了一些条件语句
4. 实现的选择
5. 客户必须了解不同的Strategy
6. Strategy和Context之间的通信开销
7. 增加了对象的数目

问题：

1. 定义Strategy和Context接口
2. 将Strategy作为模板参数
3. 使Strategy对象称为可选的

## Template Method（模板方法）——类行为模式

定义一个操作中的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构既可以重定义该算法的某些特定步骤。

适用：

* 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
* 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
* 控制子类扩展

模板方法调用以下类型的操作：

* 具体的操作
* 具体的AbstractClass的操作
* 原语操作
* Factory Method
* 钩子操作

## Visitor（访问者）——对象行为模型

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

适用：

* 一个对象结构包含很多类对象
* 需要对一个对象结构中的对象进行很多不同的并且不相关的操作
* 定义对象结构的类很少改变

优缺点：

1. 访问者模式使得易于增加新的操作
2. 访问者集中相关的操作而分离无关的操作
3. 增加新的ConcreteElement类很困难
4. 通过类层次进行访问
5. 积累状态
6. 破坏封装

# 第六章 结论

面向对象软件的生命周期常分为几个阶段：原型阶段、扩展阶段和巩固阶段。

一旦软件进入青春期并交付使用，其演化就由以下两个互相冲突的要求来决定：

1. 该软件必须满足更多的需求
2. 该软件必须更易于复用


以一种松散的方式把一些设计模式串接在一起来造建筑是可能的。这样的建筑仅仅是一些模式的堆砌而不紧凑。这不够深刻。然而另有一种组合模式的方式，许多模块重叠在同一个物理空间里：这样的建筑非常紧凑，在一小块空间里集成了许多内涵；由于这种紧凑，它变得深刻。