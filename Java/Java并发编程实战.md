# 一 基础

加入并行的原因：

1. 资源利用率
2. 公平性
3. 便利性

不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行方式时通过粗粒度的时间分片使这些用户能共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序。

线程运行在同一个进程中同时存在多个控制程序流。线程会共享进程范围内的资源。线程还通过了一种只管的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上。

在开发并发代码时，一定要注意线程安全性是不可破坏的。安全性不仅对于多线程程序很重要，对于单线程程序同样重要。

# 二 线程安全性

“共享”意味着变量可以由多个线程同时访问，而“可变”意味着变量的值在其生命周期内可以发生变化。

一个对象是否需要时线程安全的，取决于它是否被多个线程访问。

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程的对变量的访问。

如果当多个线程访问同一个可变的状态变量是没有适合的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

* 不在线程之间共享该状态变量
* 将状态变量修改为不可变的变量
* 在访问变量时使用同步

当设计线程安全的类时，良好的面向对象技术、不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。

首先代码正确运行，然后再提高代码的速度。

完全由线程安全类构成的程序并不一定就是线程安全的，而线程安全类中也可以包含飞线程安全的类。

造线程安全性的定义中，最核心的概念就是正确性。正确性的含义是，某个类的行为与其规范完全一致。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。

无状态对象一定是线程安全的。

数据竞争：是指如果在访问共享而非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争

与大多数并发错误一样，竞争条件并不总会产生错误，还需要某种不恰当的执行时序。

在实际情况中，应尽可能地使用现有的线程安全对象来管理类的状态。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量

同步快代码包括两个部分：一个座位锁的对象引用，一个作为由这个锁保护的代码块。

一关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁即是方法调用所在的对象。静态的synchronized方法一Class对象作为锁。

线程在进入同步代码块之间会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径即是进入由这个锁保护的同步代码块或方法。

任何一个执行同步代码块的线程，都不可能开到有其他线程正在执行有同一个锁保护的同步代码块。

