# 一 为什么使用Java8

在Java 8中加入 Streams 可以看作把另外两项扩充加入Java 8的直接原因：把代码传递给方法的简洁方式（方法引用、Lambda）和接口中的默认方法

在与硬件无关的内存模型里，多核处理器上的并发线程可能比在单核处理器上出现的意外行为更多

## 流处理

流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。

` Stream<T>` 就是一系列 T 类型的项目。

语言需要不断改进以跟进硬件的更新或满足程序员的期待

## Java中的函数

我们都知道软件工程中复制粘贴的危险——给一个做了更新和修正，却忘了另一个。

## 流

通过多线程代码来利用并行（使用先前Java版本中的Thread API）并非易事。

线程可能会同时访问并更新共享变量。因此，如果没有协调好，数据可能会被意外改变。

Collection主要是为了存储和访问数据，而Stream则主要用于描述对数据的计算。

## 默认方法

使用default进行修饰

以下是你应从本章中学到的关键概念。

* 请记住语言生态系统的思想，以及语言面临的“要么改变，要么衰亡”的压力。虽然Java可能现在非常有活力，但你可以回忆一下其他曾经也有活力但未能及时改进的语言的命运，如COBOL。
* Java 8中新增的核心内容提供了令人激动的新概念和功能，方便我们编写既有效又简洁的程序。
* 现有的Java编程实践并不能很好地利用多核处理器。
* 函数是一等值；记得方法如何作为函数式值来传递，还有Lambda是怎样写的。
* Java 8中 Streams 的概念使得 Collections 的许多方面得以推广，让代码更为易读，并允许并行处理流元素。
* 你可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容。
* 其他来自函数式编程的有趣思想，包括处理 null 和使用模式匹配。

# 二 通过行为参数化传递代码

行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。

行为参数化：

1. 传递代码行为
2. 多种行为，一个参数

匿名内部类的坏处：

1. 往往很笨重，因为它占用了很多空间
2. 难以让人理解

![行为参数化与值参数化](../Image/Java8实战/行为参数化与值参数化.jpg)

小结：

* 行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。
* 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。
* 传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。
* Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理

# 三 Lambda表达式

可以把Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。

lambda表达式的基本语法：

```java
(parameters) -> expression
```

或者：

```java
(parameters) -> { statements; }
```

**函数式接口就是只定义一个抽象方法的接口**,哪怕有很多默认方法，只要接口只定义了一个抽象
方法它就仍然是一个函数式接口。

java.util.function.Predicate<T> 接口定义了一个名叫 test 的抽象方法，它接受泛型T 对象，并返回一个 boolean 。

java.util.function.Consumer<T> 定义了一个名叫 accept 的抽象方法，它接受泛型 T的对象，没有返回（ void ）。

java.util.function.Function<T, R> 接口定义了一个叫作 apply 的方法，它接受一个泛型 T 的对象，并返回一个泛型 R 的对象。

![常用函数式接口1](../Image/Java8实战/常用函数式接口1.jpg)

![常用函数式接口2](../Image/Java8实战/常用函数式接口2.jpg)

ava编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。

Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，或事实上是 final 。

对局部变量的限制：

1. 实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。
2. 这一限制不鼓励你使用改变外部变量的典型命令式编程模式

方法引用：

1. 指向静态方法的方法引用
2. 指向任意类型实例方法的方法应用
3. 指向 现有对象的实例方法引用

对于一个现有构造函数，你可以利用它的名称和关键字 new 来创建它的一个引用：`ClassName::new` 。

以下是你应从本章中学到的关键概念。

* Lambda 表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。
* Lambda 表达式让你可以简洁地传递代码。
* 函数式接口就是仅仅声明了一个抽象方法的接口。
* 只有在接受函数式接口的地方才可以使用 Lambda 表达式。
* Lambda 表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。
* Java 8 自带一些常用的函数式接口，放在 java.util.function 包里，包括 Predicate<T> 、 Function<T,R> 、 Supplier<T> 、 Consumer<T> 和 BinaryOperator<T> ，如表
* 为了避免装箱操作，对 Predicate<T> 和 Function<T, R> 等通用函数式接口的原始类型特化： IntPredicate 、 IntToLongFunction 等。
* 环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理）可以配合 Lambda 提高灵活性和可重用性。
* Lambda 表达式所需要代表的类型称为目标类型。
* 方法引用让你重复使用现有的方法实现并直接传递它们。
* Comparator 、 Predicate 和 Function 等函数式接口都有几个可以用来结合 Lambda 表达式的默认方法。

# 四 使用流

好处：

* 代码是以声明性方式写的
* 可以将几个基础操作链接起来，来表达复杂的数据处理流水线

Java 8中的Stream API可以让你写出这样的代码：

* 声明性——更简洁，更易读
* 可复合——更灵活
* 可并行——性能更好

集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。

流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。

请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样。

Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。与此相反，一旦通过写 for-each 而选择了外部迭代，那你基本上就要自己管理所有的并行问题了。

总而言之，流的使用一般包括三件事：

*　一个数据源（如集合）来执行一个查询；
*　一个中间操作链，形成一条流的流水线；
*　一个终端操作，执行流水线，并能生成结果。

![流操作](../Image/Java8实战/流操作.jpg)

小结：

* 流是“从支持数据处理操作的源生成的一系列元素”。
* 流利用内部迭代：迭代通过 filter 、 map 、 sorted 等操作被抽象掉了。
* 流操作有两类：中间操作和终端操作。
* filter 和 map 等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果。
* forEach 和 count 等终端操作会返回一个非流的值，并处理流水线以返回结果。
* 流中的元素是按需计算的

# 五 使用流

Streams 接口支持 filter 方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回boolean 的函数）作为参数，并返回一个包括所有符合谓词的元素的流。

流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的hashCode 和 equals 方法实现）的流。

流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给 limit 。如果流是有序的，则最多会返回前 n 个元素。

流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。如果流中元素不足 n 个，则返回一个空流。

使用 flatMap 方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。

一言以蔽之， flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。

anyMatch 方法可以回答“流中是否有一个元素能匹配给定的谓词”。

allMatch 方法的工作原理和 anyMatch 类似，但它会看看流中的元素是否都能匹配给定的谓词。

 noneMatch 它可以确保流中没有任何元素与给定的谓词匹配。

reduce 接受两个参数：

* 一个初始值，这里是0；
* 一个 `BinaryOperator<T> `来将两个元素结合起来产生一个新值

![中间操作和终端操作](..\Image\Java8实战\中间操作和终端操作.jpg)

Java 8引入了三个原始类型特化流接口来解决这个问题： IntStream 、 DoubleStream 和LongStream ，分别将流中的元素特化为 int 、 long 和 double ，从而避免了暗含的装箱成本。

将流转换为特化版本的常用方法是 mapToInt 、 mapToDouble 和 mapToLong 。

 Optional 可以用Integer 、 String 等参考类型来参数化。对于三种原始流特化，也分别有一个 Optional 原始类型特化版本： OptionalInt 、 OptionalDouble 和 OptionalLong 。

Stream API提供了两个静态方法来从函数生成流： Stream.iterate 和 Stream.generate 。这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由 iterate和 generate 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！一般来说，应该使用 limit(n) 来对这种流加以限制，以避免打印无穷多个值。

小结：

* Streams API可以表达复杂的数据处理查询
* 你可以使用 filter 、 distinct 、 skip 和 limit 对流做筛选和切片。
* 你可以使用 map 和 flatMap 提取或转换流中的元素。
* 你可以使用 findFirst 和 findAny 方法查找流中的元素。你可以用 allMatch 、noneMatch 和 anyMatch 方法让流匹配给定的谓词。
* 这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流。
* 你可以利用 reduce 方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。
* filter 和 map 等操作是无状态的，它们并不存储任何状态。 reduce 等操作要存储状态才能计算出一个值。 sorted 和 distinct 等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。
* 流有三种基本的原始类型特化： IntStream 、 DoubleStream 和 LongStream 。它们的操作也有相应的特化。
* 流不仅可以从集合创建，也可从值、数组、文件以及 iterate 与 generate 等特定方法创建。
* 无限流是没有固定大小的流

# 六 用流收集数据

一般来说， Collector 会对元素应用一个转换函数，并将结果累积在一个数据结构中，从而产生这一过程的最终输出。

预定义收集器的功能，也就是那些可以从 Collectors类提供的工厂方法（例如 groupingBy ）创建的收集器。它们主要提供了三大功能：

* 将流元素归约和汇总为一个值
* 元素分组
* 元素分区

![Collectors 类的静态工厂方法](..\Image\Java8实战\Collectors 类的静态工厂方法.jpg)

![Collectors 类的静态工厂方法2](..\Image\Java8实战\Collectors 类的静态工厂方法2.jpg)

Collector接口的声明：

1. 建立新的结果容器：supplier方法
2. 将元素添加到结果容器： accumulator 方法
3. 对结果容器应用最终转换： finisher 方法
4. 合并两个结果容器： combiner 方法
5. characteristics 方法

 characteristics 会返回一个不可变的 Characteristics 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。Characteristics 是一个包含三个项目的枚举。

* UNORDERED ——归约结果不受流中项目的遍历和累积顺序的影响。
* CONCURRENT —— accumulator 函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约。
* IDENTITY_FINISH ——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 A 不加检查地转换为结果 R 是安全的。

小结：

* collect 是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器）。
* 预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。
* 预定义收集器可以用 groupingBy 对流中元素进行分组，或用 partitioningBy 进行分区。
* 收集器可以高效地复合起来，进行多级分组、分区和归约。
* 你可以实现 Collector 接口中定义的方法来开发你自己的收集器。

# 七 并行数据处理与性能

## 并行流

并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。

对顺序流调用 parallel 方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。类似地，你只需要对并行流调sequential 方法就可以把它变成顺序流。

**特别是在优化性能时，你应该始终遵循三个黄金规则：测量，测量，再测量。**

用传统 for 循环的迭代版本执行起来应该会快很多，因为它更为底层，更重要的是不需要对原始类型做任何装箱或拆箱操作。

**并行化并不是没有代价的。**并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。