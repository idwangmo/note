---
title: Go语言实战
footer: MIT Licensed | Copyright © 2018-present idwangmo
prev: /
next: ./build-web-application-with-golang
sidebar: auto
---

# Go语言实战

## 第一章

如果一个类型实现了一个接口的所有方法，那么这个类型的实 例就可以存储在这个接口类型的实例中，不需要额外声明

Go 语言的接口一般只会描述一个单一的动作

使用同一个接口， 可以高效地操作数据， 而不用考虑到底数据 来自哪里

## 第二章

Go 编译器不允许声明导入某个包却不使用。下划线让编译器接受这类导入，并且 调用对应包内的所有代码文件里定义的 init 函数

在 Go 语言中，所有变量都被初始化为其零值。对于数值类型，零值是 0 ；对于字符串类型， 零值是空字符串；对于布尔类型，零值是 false ；对于指针，零值是 nil 。对于引用类型来说， 所引用的底层数据结构会被初始化为对应的零值。但是被声明为其零值的引用类型的变量，会返 回 nil 作为其值。

如果需要声明初始值为零值 的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回 值创建变量，应该使用简化变量声明运算符。

写并发程序的时候，最佳做法是，在 main 函数返回前，清理 并终止所有之前启动的 goroutine。

如果 要调用的函数返回多个值，而又不需要其中的某个值，就可以使用下划线标识符将其忽略。

使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函 数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。

因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法 的接收者声明为指针。

使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时 候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。

每个代码文件都属于一个包，而包名应该与代码文件所在的文件夹同名

使用指针可以在函数间或者 goroutine 间共享数据

## 第三章

同一个目录下的所有的文件必须声明同一个包

每个包可以包含任意多个init函数，这些函数都会在程序执行开始的时候被调用

## 第四章

切片是对底层数组进行了抽象，其有三个字段，分别指向底层数组的指针、切片访问元素的个数和切片允许增长到的元素个数

如果在`[]`运算符中指定了一个值，那么创建的就是数组而不是切片

对于 slice[i:j:k] 或 [2:3:4]

长度: j – i 或 3 - 2 = 1

容量: k – i 或 4 - 2 = 2

如果在新切片创建是设置切片的容量和长度一样，就可以强制让新切片的第一个append操作创建新的底层数组，与原有的底层数组分离。其先增长切片，然后再将新的切片复制给外层切片的第一个元素。

通过键来索引映射时，即便这个键不存在也总会返回一个值。

## 第五章

### 用户自定义类型

值的类型给编译器提供两部分信息：第一部分，需要分配多少内存给这个值；第二部分，这个内存表示什么。

初始化值：对数值类型来说，零值是 0；对字符串来说，零值是空字符串；对布尔类型，零值是 false。

定义类型的方式可以定义一个结构体，或者基于一个已有的类型，将其作为新类型说明

两种不同类型的值即便相互兼容，也不能互相赋值

### 类型的本质

go中有两种类型的接受着：值接受着和指针接受着

标头值里有一个执政，因此通过复制来传递一个引用类型的值的副本，本质上就是在共享底层数据结构

当要围绕相关的内置类型或者引用类型来声明用户定义的行为时，直接基于已有类型来声明用户定义的类型会很好用。

### 标识符的公开性质

main 函数能够接受这个值并创建一个未公开的类型的变量。要让这个行为可行，需要两个理由。第一，公开或者未公开的标识符，不是一个值。第二，短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量。永远不能显式创建一个未公开的类型的变量，不过短变量声明操作符可以这么做
