<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 8 实战 | 墨语笔记补完</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="日常读书笔记、每日的文章阅读重要部分注记录">
    <meta property="article:modified_time" content="2019-08-21T16:21:44.000Z">
    <meta property="og:site_name" content="墨语笔记补完">
    <meta property="og:title" content="Java 8 实战">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/java/java8-in-action.html">
    <meta name="twitter:title" content="Java 8 实战">
    <meta name="twitter:url" content="/java/java8-in-action.html">
    <meta name="twitter:card" content="summary_large_image">
    <link rel="preload" href="/assets/css/0.styles.36294c82.css" as="style"><link rel="preload" href="/assets/js/app.cccfd8e7.js" as="script"><link rel="preload" href="/assets/js/2.9de5c6c1.js" as="script"><link rel="preload" href="/assets/js/4.a7183ff4.js" as="script"><link rel="prefetch" href="/assets/js/10.d6241704.js"><link rel="prefetch" href="/assets/js/11.67fb7f7f.js"><link rel="prefetch" href="/assets/js/12.e5c25b76.js"><link rel="prefetch" href="/assets/js/13.1ba667dd.js"><link rel="prefetch" href="/assets/js/14.cf11d9fa.js"><link rel="prefetch" href="/assets/js/15.4956305a.js"><link rel="prefetch" href="/assets/js/16.2c48f3c9.js"><link rel="prefetch" href="/assets/js/17.478a5e4c.js"><link rel="prefetch" href="/assets/js/18.f6c443cd.js"><link rel="prefetch" href="/assets/js/19.782e6682.js"><link rel="prefetch" href="/assets/js/20.9497fcb7.js"><link rel="prefetch" href="/assets/js/21.14aafb81.js"><link rel="prefetch" href="/assets/js/22.2668548e.js"><link rel="prefetch" href="/assets/js/23.e18d4f59.js"><link rel="prefetch" href="/assets/js/24.0494627e.js"><link rel="prefetch" href="/assets/js/25.e6d2f928.js"><link rel="prefetch" href="/assets/js/26.5b3e12f5.js"><link rel="prefetch" href="/assets/js/27.2ea04455.js"><link rel="prefetch" href="/assets/js/28.f54943d4.js"><link rel="prefetch" href="/assets/js/29.0d21d124.js"><link rel="prefetch" href="/assets/js/3.7c1461c0.js"><link rel="prefetch" href="/assets/js/30.51e7e3da.js"><link rel="prefetch" href="/assets/js/31.b6fd8416.js"><link rel="prefetch" href="/assets/js/32.288e3649.js"><link rel="prefetch" href="/assets/js/33.2fed9cff.js"><link rel="prefetch" href="/assets/js/34.4c6a8953.js"><link rel="prefetch" href="/assets/js/35.64749222.js"><link rel="prefetch" href="/assets/js/36.d523088c.js"><link rel="prefetch" href="/assets/js/37.df0319c9.js"><link rel="prefetch" href="/assets/js/38.1281fec2.js"><link rel="prefetch" href="/assets/js/39.090c1406.js"><link rel="prefetch" href="/assets/js/40.54ef8cf7.js"><link rel="prefetch" href="/assets/js/41.36e152bb.js"><link rel="prefetch" href="/assets/js/42.7c813979.js"><link rel="prefetch" href="/assets/js/43.6b73d645.js"><link rel="prefetch" href="/assets/js/44.0f59db0e.js"><link rel="prefetch" href="/assets/js/45.2a5cf763.js"><link rel="prefetch" href="/assets/js/46.6d860222.js"><link rel="prefetch" href="/assets/js/47.c5dc6374.js"><link rel="prefetch" href="/assets/js/48.22502cc5.js"><link rel="prefetch" href="/assets/js/49.446fdcce.js"><link rel="prefetch" href="/assets/js/5.86c48d13.js"><link rel="prefetch" href="/assets/js/50.505b1863.js"><link rel="prefetch" href="/assets/js/6.dd5bb6a5.js"><link rel="prefetch" href="/assets/js/7.b915e335.js"><link rel="prefetch" href="/assets/js/8.340fe880.js"><link rel="prefetch" href="/assets/js/9.b4c5caee.js">
    <link rel="stylesheet" href="/assets/css/0.styles.36294c82.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">墨语笔记补完</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://www.idwangmo.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  墨语的后花园
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/idwangmo/note" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://www.idwangmo.top" target="_blank" rel="noopener noreferrer" class="nav-link external">
  墨语的后花园
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/idwangmo/note" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java 8 实战</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/java8-in-action.html#一-为什么使用-java8" class="sidebar-link">一 为什么使用 Java8</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#流处理" class="sidebar-link">流处理</a></li><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#java-中的函数" class="sidebar-link">Java 中的函数</a></li><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#流" class="sidebar-link">流</a></li><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#默认方法" class="sidebar-link">默认方法</a></li></ul></li><li><a href="/java/java8-in-action.html#二-通过行为参数化传递代码" class="sidebar-link">二 通过行为参数化传递代码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#三-lambda-表达式" class="sidebar-link">三 Lambda 表达式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#四-使用流" class="sidebar-link">四 使用流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#五-使用流" class="sidebar-link">五 使用流</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#六-用流收集数据" class="sidebar-link">六 用流收集数据</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#七-并行数据处理与性能" class="sidebar-link">七 并行数据处理与性能</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#并行流" class="sidebar-link">并行流</a></li><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#分支-合并框架" class="sidebar-link">分支/合并框架</a></li><li class="sidebar-sub-header"><a href="/java/java8-in-action.html#spliterator" class="sidebar-link">Spliterator</a></li></ul></li><li><a href="/java/java8-in-action.html#八-重构、测试和调试" class="sidebar-link">八 重构、测试和调试</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#九-默认方法" class="sidebar-link">九 默认方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#十一-completablefuture：组合式异步编程" class="sidebar-link">十一 CompletableFuture：组合式异步编程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#十二-新的日期和时间-api" class="sidebar-link">十二 新的日期和时间 API</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#十三-函数式思考" class="sidebar-link">十三 函数式思考</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#十四-函数式编程技巧" class="sidebar-link">十四 函数式编程技巧</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#十五-面向对象和函数式编程的混合：java-8-和-scala-的比较" class="sidebar-link">十五 面向对象和函数式编程的混合：Java 8 和 Scala 的比较</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/java/java8-in-action.html#其它新特性" class="sidebar-link">其它新特性</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="一-为什么使用-java8"><a href="#一-为什么使用-java8" class="header-anchor">#</a> 一 为什么使用 Java8</h2> <p>在 Java 8 中加入 Streams 可以看作把另外两项扩充加入 Java 8 的直接原因：把代码传递给方法的简洁方式（方法引用、Lambda）和接口中的默认方法</p> <p>在与硬件无关的内存模型里，多核处理器上的并发线程可能比在单核处理器上出现的意外行为更多</p> <h3 id="流处理"><a href="#流处理" class="header-anchor">#</a> 流处理</h3> <p>流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，然后以同样的方式将数据项写入输出流。一个程序的输出流很可能是另一个程序的输入流。</p> <p><code>Stream&lt;T&gt;</code> 就是一系列 T 类型的项目。</p> <p>语言需要不断改进以跟进硬件的更新或满足程序员的期待</p> <h3 id="java-中的函数"><a href="#java-中的函数" class="header-anchor">#</a> Java 中的函数</h3> <p>我们都知道软件工程中复制粘贴的危险——给一个做了更新和修正，却忘了另一个。</p> <h3 id="流"><a href="#流" class="header-anchor">#</a> 流</h3> <p>通过多线程代码来利用并行（使用先前 Java 版本中的 Thread API）并非易事。</p> <p>线程可能会同时访问并更新共享变量。因此，如果没有协调好，数据可能会被意外改变。</p> <p>Collection 主要是为了存储和访问数据，而 Stream 则主要用于描述对数据的计算。</p> <h3 id="默认方法"><a href="#默认方法" class="header-anchor">#</a> 默认方法</h3> <p>使用 default 进行修饰</p> <p>以下是你应从本章中学到的关键概念。</p> <ul><li>请记住语言生态系统的思想，以及语言面临的“要么改变，要么衰亡”的压力。虽然 Java 可能现在非常有活力，但你可以回忆一下其他曾经也有活力但未能及时改进的语言的命运，如 COBOL。</li> <li>Java 8 中新增的核心内容提供了令人激动的新概念和功能，方便我们编写既有效又简洁的程序。</li> <li>现有的 Java 编程实践并不能很好地利用多核处理器。</li> <li>函数是一等值；记得方法如何作为函数式值来传递，还有 Lambda 是怎样写的。</li> <li>Java 8 中 Streams 的概念使得 Collections 的许多方面得以推广，让代码更为易读，并允许并行处理流元素。</li> <li>你可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容。</li> <li>其他来自函数式编程的有趣思想，包括处理 null 和使用模式匹配。</li></ul> <h2 id="二-通过行为参数化传递代码"><a href="#二-通过行为参数化传递代码" class="header-anchor">#</a> 二 通过行为参数化传递代码</h2> <p>行为参数化就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。</p> <p>行为参数化：</p> <ol><li>传递代码行为</li> <li>多种行为，一个参数</li></ol> <p>匿名内部类的坏处：</p> <ol><li>往往很笨重，因为它占用了很多空间</li> <li>难以让人理解</li></ol> <p><img src="/assets/img/behavioral-parameterrization.dba458de.jpg" alt="行为参数化与值参数化"></p> <p>小结：</p> <ul><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li> <li>行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。</li> <li>传递代码，就是将新行为作为参数传递给方法。但在 Java 8 之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在 Java 8 之前可以用匿名类来减少。</li> <li>Java API 包含很多可以用不同行为进行参数化的方法，包括排序、线程和 GUI 处理</li></ul> <h2 id="三-lambda-表达式"><a href="#三-lambda-表达式" class="header-anchor">#</a> 三 Lambda 表达式</h2> <p>可以把 Lambda 表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p> <p>lambda 表达式的基本语法：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> expression
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>或者：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> statements<span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>函数式接口就是只定义一个抽象方法的接口</strong>,哪怕有很多默认方法，只要接口只定义了一个抽象
方法它就仍然是一个函数式接口。</p> <p><code>java.util.function.Predicate&lt;T&gt;</code> 接口定义了一个名叫 test 的抽象方法，它接受泛型 T 对象，并返回一个 boolean 。</p> <p><code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫 accept 的抽象方法，它接受泛型 T 的对象，没有返回（ void ）。</p> <p>java.util.function.Function&lt;T, R&gt; 接口定义了一个叫作 apply 的方法，它接受一个泛型 T 的对象，并返回一个泛型 R 的对象。</p> <p><img src="/assets/img/function-interface-1.f7bf5f91.jpg" alt="常用函数式接口1"></p> <p><img src="/assets/img/function-interface-2.5e8e477e.jpg" alt="常用函数式接口2"></p> <p>ava 编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式，这意味着它也可以推断出适合 Lambda 的签名，因为函数描述符可以通过目标类型来得到。</p> <p>Lambda 可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为 final ，或事实上是 final 。</p> <p>对局部变量的限制：</p> <ol><li>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果 Lambda 可以直接访问局部变量，而且 Lambda 是在一个线程中使用的，则使用 Lambda 的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。</li> <li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式</li></ol> <p>方法引用：</p> <ol><li>指向静态方法的方法引用</li> <li>指向任意类型实例方法的方法应用</li> <li>指向 现有对象的实例方法引用</li></ol> <p>对于一个现有构造函数，你可以利用它的名称和关键字 new 来创建它的一个引用：<code>ClassName::new</code> 。</p> <p>以下是你应从本章中学到的关键概念。</p> <ul><li>Lambda 表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。</li> <li>Lambda 表达式让你可以简洁地传递代码。</li> <li>函数式接口就是仅仅声明了一个抽象方法的接口。</li> <li>只有在接受函数式接口的地方才可以使用 Lambda 表达式。</li> <li>Lambda 表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</li> <li>Java 8 自带一些常用的函数式接口，放在 java.util.function 包里，包括 <code>Predicate&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Supplier&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>和<code>BinaryOperator&lt;T&gt;</code>，如表</li> <li>为了避免装箱操作，对<code>Predicate&lt;T&gt;</code>和<code>Function&lt;T, R&gt;</code>等通用函数式接口的原始类型特化： IntPredicate 、 IntToLongFunction 等。</li> <li>环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理）可以配合 Lambda 提高灵活性和可重用性。</li> <li>Lambda 表达式所需要代表的类型称为目标类型。</li> <li>方法引用让你重复使用现有的方法实现并直接传递它们。</li> <li>Comparator 、 Predicate 和 Function 等函数式接口都有几个可以用来结合 Lambda 表达式的默认方法。</li></ul> <h2 id="四-使用流"><a href="#四-使用流" class="header-anchor">#</a> 四 使用流</h2> <p>好处：</p> <ul><li>代码是以声明性方式写的</li> <li>可以将几个基础操作链接起来，来表达复杂的数据处理流水线</li></ul> <p>Java 8 中的 Stream API 可以让你写出这样的代码：</p> <ul><li>声明性——更简洁，更易读</li> <li>可复合——更灵活</li> <li>可并行——性能更好</li></ul> <p>集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。</p> <p>流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。</p> <p>请注意，和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样。</p> <p>Streams 库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。与此相反，一旦通过写 for-each 而选择了外部迭代，那你基本上就要自己管理所有的并行问题了。</p> <p>总而言之，流的使用一般包括三件事：</p> <p>*　一个数据源（如集合）来执行一个查询；
*　一个中间操作链，形成一条流的流水线； *　一个终端操作，执行流水线，并能生成结果。</p> <p><img src="/assets/img/stream-operator.f4a051b1.jpg" alt="流操作"></p> <p>小结：</p> <ul><li>流是“从支持数据处理操作的源生成的一系列元素”。</li> <li>流利用内部迭代：迭代通过 filter 、 map 、 sorted 等操作被抽象掉了。</li> <li>流操作有两类：中间操作和终端操作。</li> <li>filter 和 map 等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果。</li> <li>forEach 和 count 等终端操作会返回一个非流的值，并处理流水线以返回结果。</li> <li>流中的元素是按需计算的</li></ul> <h2 id="五-使用流"><a href="#五-使用流" class="header-anchor">#</a> 五 使用流</h2> <p>Streams 接口支持 filter 方法（你现在应该很熟悉了）。该操作会接受一个谓词（一个返回 boolean 的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p> <p>流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的 hashCode 和 equals 方法实现）的流。</p> <p>流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给 limit 。如果流是有序的，则最多会返回前 n 个元素。</p> <p>流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。如果流中元素不足 n 个，则返回一个空流。</p> <p>使用 flatMap 方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。</p> <p>一言以蔽之， flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</p> <p>anyMatch 方法可以回答“流中是否有一个元素能匹配给定的谓词”。</p> <p>allMatch 方法的工作原理和 anyMatch 类似，但它会看看流中的元素是否都能匹配给定的谓词。</p> <p>noneMatch 它可以确保流中没有任何元素与给定的谓词匹配。</p> <p>reduce 接受两个参数：</p> <ul><li>一个初始值，这里是 0；</li> <li>一个 <code>BinaryOperator&lt;T&gt;</code>来将两个元素结合起来产生一个新值</li></ul> <p><img src="/assets/img/Intermediate-and-terminal-operations.717c7d22.jpg" alt="中间操作和终端操作"></p> <p>Java 8 引入了三个原始类型特化流接口来解决这个问题： IntStream 、 DoubleStream 和 LongStream ，分别将流中的元素特化为 int 、 long 和 double ，从而避免了暗含的装箱成本。</p> <p>将流转换为特化版本的常用方法是 mapToInt 、 mapToDouble 和 mapToLong 。</p> <p>Optional 可以用 Integer 、 String 等参考类型来参数化。对于三种原始流特化，也分别有一个 Optional 原始类型特化版本： OptionalInt 、 OptionalDouble 和 OptionalLong 。</p> <p>Stream API 提供了两个静态方法来从函数生成流： Stream.iterate 和 Stream.generate 。这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由 iterate 和 generate 产生的流会用给定的函数按需创建值，因此可以无穷无尽地计算下去！一般来说，应该使用 limit(n) 来对这种流加以限制，以避免打印无穷多个值。</p> <p>小结：</p> <ul><li>Streams API 可以表达复杂的数据处理查询</li> <li>你可以使用 filter 、 distinct 、 skip 和 limit 对流做筛选和切片。</li> <li>你可以使用 map 和 flatMap 提取或转换流中的元素。</li> <li>你可以使用 findFirst 和 findAny 方法查找流中的元素。你可以用 allMatch 、noneMatch 和 anyMatch 方法让流匹配给定的谓词。</li> <li>这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流。</li> <li>你可以利用 reduce 方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。</li> <li>filter 和 map 等操作是无状态的，它们并不存储任何状态。 reduce 等操作要存储状态才能计算出一个值。 sorted 和 distinct 等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。</li> <li>流有三种基本的原始类型特化： IntStream 、 DoubleStream 和 LongStream 。它们的操作也有相应的特化。</li> <li>流不仅可以从集合创建，也可从值、数组、文件以及 iterate 与 generate 等特定方法创建。</li> <li>无限流是没有固定大小的流</li></ul> <h2 id="六-用流收集数据"><a href="#六-用流收集数据" class="header-anchor">#</a> 六 用流收集数据</h2> <p>一般来说， Collector 会对元素应用一个转换函数，并将结果累积在一个数据结构中，从而产生这一过程的最终输出。</p> <p>预定义收集器的功能，也就是那些可以从 Collectors 类提供的工厂方法（例如 groupingBy ）创建的收集器。它们主要提供了三大功能：</p> <ul><li>将流元素归约和汇总为一个值</li> <li>元素分组</li> <li>元素分区</li></ul> <p><img src="/assets/img/collectors-static-factor-methods-1.e7236011.jpg" alt="Collectors 静态工厂类方法"></p> <p><img src="/assets/img/collectors-static-factor-methods-2.974d9fad.jpg" alt="Collectors 类静态工厂方法2"></p> <p>Collector 接口的声明：</p> <ol><li><p>建立新的结果容器：supplier 方法</p></li> <li><p>将元素添加到结果容器： accumulator 方法</p></li> <li><p>对结果容器应用最终转换： finisher 方法</p></li> <li><p>合并两个结果容器： combiner 方法</p></li> <li><p>characteristics 方法</p> <p>characteristics 会返回一个不可变的 Characteristics 集合，它定义了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示。Characteristics 是一个包含三个项目的枚举。</p></li></ol> <ul><li>UNORDERED ——归约结果不受流中项目的遍历和累积顺序的影响。</li> <li>CONCURRENT —— accumulator 函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为 UNORDERED ，那它仅在用于无序数据源时才可以并行归约。</li> <li>IDENTITY_FINISH ——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器 A 不加检查地转换为结果 R 是安全的。</li></ul> <p>小结：</p> <ul><li>collect 是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器）。</li> <li>预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。</li> <li>预定义收集器可以用 groupingBy 对流中元素进行分组，或用 partitioningBy 进行分区。</li> <li>收集器可以高效地复合起来，进行多级分组、分区和归约。</li> <li>你可以实现 Collector 接口中定义的方法来开发你自己的收集器。</li></ul> <h2 id="七-并行数据处理与性能"><a href="#七-并行数据处理与性能" class="header-anchor">#</a> 七 并行数据处理与性能</h2> <h3 id="并行流"><a href="#并行流" class="header-anchor">#</a> 并行流</h3> <p>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p> <p>对顺序流调用 parallel 方法并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。类似地，你只需要对并行流调 sequential 方法就可以把它变成顺序流。</p> <p><strong>特别是在优化性能时，你应该始终遵循三个黄金规则：测量，测量，再测量。</strong></p> <p>用传统 for 循环的迭代版本执行起来应该会快很多，因为它更为底层，更重要的是不需要对原始类型做任何装箱或拆箱操作。</p> <p>**并行化并不是没有代价的。**并行化过程本身需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，然后把这些操作的结果合并成一个值。</p> <p>决定使用并行流的条件：</p> <ul><li>如果有疑问，测量</li> <li>留意装箱</li> <li>有些操作本身在并行流上执行的代建非常大</li> <li>考虑流的操作流水线的总计算成本</li> <li>对于较小的数据量，选择并行流几乎从来都不是一个号的决定</li> <li>考虑流背后的数据结构是否易于分解</li> <li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。</li> <li>还要考虑终端操作中合并步骤的代价是大是小</li></ul> <p><img src="/assets/img/stream-operator.f4a051b1.jpg" alt="流的数据源和可分解性"></p> <h3 id="分支-合并框架"><a href="#分支-合并框架" class="header-anchor">#</a> 分支/合并框架</h3> <p><img src="/assets/img/fork-join.31f4db11.jpg" alt="分支合并过程"></p> <p>**在实际应用时，使用多个 ForkJoinPool 是没有什么意义的。**一般来说把它实例化一次，然后把实例保存在静态字段中，使之成为单例，这样就可以在软件中任何部分方便地重用了。</p> <p>使用分支/合并框架的最佳做法：</p> <ul><li>对一个任务调用 join 方法会阻塞调用方，直到该任务做出结果。</li> <li>不应该在 RecursiveTask 内部使用 ForkJoinPool 的 invoke 方法。相反，你应该始终直接调用 compute 或 fork 方法，只有顺序代码才应该用 invoke 来启动并行计算。</li> <li>对子任务调用 fork 方法可以把它排进 ForkJoinPool 。</li> <li>调试使用分支/合并框架的并行计算可能有点棘手。</li> <li>和并行流一样，你不应理所当然地认为在多核处理器上使用分支/合并框架就比顺序计算快。</li></ul> <p>分支/合并框架工程用一种称为工作窃取（work stealing）的技术来解决这个问题。在实际应用中，这意味着这些任务差不多被平均分配到 ForkJoinPool 中的所有线程上。每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。</p> <h3 id="spliterator"><a href="#spliterator" class="header-anchor">#</a> Spliterator</h3> <p>Spliterator 是 Java 8 中加入的另一个新接口；这个名字代表“可分迭代器”（splitableiterator）。</p> <p><img src="/assets/img/Spliterator.1ce6faea.jpg" alt="Spliterator的特性"></p> <p>小结:</p> <ul><li>内部迭代让你可以并行处理一个流，而无需在代码中显式使用和协调不同的线程。</li> <li>虽然并行处理一个流很容易，却不能保证程序在所有情况下都运行得更快。并行软件的行为和性能有时是违反直觉的，因此一定要测量，确保你并没有把程序拖得更慢。</li> <li>像并行流那样对一个数据集并行执行操作可以提升性能，特别是要处理的元素数量庞大，或处理单个元素特别耗时的时候。</li> <li>从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，几乎总是比尝试并行化某些操作更为重要。</li> <li>分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。</li> <li>Spliterator 定义了并行流如何拆分它要遍历的数据。</li></ul> <h2 id="八-重构、测试和调试"><a href="#八-重构、测试和调试" class="header-anchor">#</a> 八 重构、测试和调试</h2> <p>在涉及重载的上下文里，将匿名类转换为 Lambda 表达式可能导致最终的代码更加晦涩。</p> <p>策略模式包含三部分内容：</p> <ul><li>一个代表某个算法的接口（它是策略模式的接口）。</li> <li>一个或多个该接口的具体实现，它们代表了算法的多种实现</li> <li>一个或多个使用策略对象的客户。</li></ul> <p>这些表示错误发生在 Lambda 表达式内部。由于 Lambda 表达式没有名字，所以编译器只能为它们指定一个名字。</p> <p>如果方法引用指向的是同一个类中声明的方法，那么它的名称是可以在栈跟踪中显示的。</p> <p>这就是流操作方法 peek 大显身手的时候。 peek 的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。但是它不像 forEach 那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会将操作顺承到流水线中的下一个操作。</p> <p>小结：</p> <ul><li>Lambda 表达式能提升代码的可读性和灵活性。</li> <li>如果你的代码中使用了匿名类，尽量用 Lambda 表达式替换它们，但是要注意二者间语义的微妙差别，比如关键字 this ，以及变量隐藏。</li> <li>跟 Lambda 表达式比起来，方法引用的可读性更好 。、</li> <li>尽量使用 Stream API 替换迭代式的集合处理。</li> <li>Lambda 表达式有助于避免使用面向对象设计模式时容易出现的僵化的模板代码，典型的比如策略模式、模板方法、观察者模式、责任链模式，以及工厂模式。</li> <li>即使采用了 Lambda 表达式，也同样可以进行单元测试，但是通常你应该关注使用了 Lambda 表达式的方法的行为。</li> <li>尽量将复杂的 Lambda 表达式抽象到普通方法中。</li> <li>Lambda 表达式会让栈跟踪的分析变得更为复杂。</li> <li>流提供的 peek 方法在分析 Stream 流水线时，能将中间变量的值输出到日志中，是非常有用的工具。</li></ul> <h2 id="九-默认方法"><a href="#九-默认方法" class="header-anchor">#</a> 九 默认方法</h2> <p>其一，Java 8 允许在接口内声明静态方法。其二，Java 8 引入了一个新功能，叫默认方法，通过默认方法
你可以指定接口方法的默认实现。</p> <p><strong>默认方法的主要目标用户是类库的设计者啊</strong></p> <p>变更对 Java 程序的影响大体可以分成三种类型的兼容性，分别是：二进制级的兼容、源代码级的兼容，以及函数行为的兼容。</p> <p><strong>String 类被声明为 final ，因为我们不希望有人对这样的核心功能产生干扰。</strong></p> <p>解决继承问题的三条规则：</p> <ol><li>类中的方法优先级最高</li> <li>如果无法依据第一条进行判断，那么子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果 B 继承了 A ，那么 B 就比 A 更加具体。</li> <li>最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式地选择使用哪一个默认方法的实现。</li></ol> <p>Java 8 中引入了一种新的语法 X.super.m(…) ，其中 X 是你希望调用的 m 方法所在的父接口。</p> <p><img src="/assets/img/Intermediate-and-terminal-operations.717c7d22.jpg" alt="菱形继承问题"></p> <p>你只需要遵守下面这三条准则就能解决所有可能的冲突：</p> <ol><li>首先，类或父类中显式声明的方法，其优先级高于所有的默认方法。</li> <li>如果用第一条无法判断，方法签名又没有区别，那么选择提供最具体实现的默认方法的接口。</li> <li>最后，如果冲突依旧无法解决，你就只能在你的类中覆盖该默认方法，显式地指定在你的类中使用哪一个接口中的方法。</li></ol> <p>小结：</p> <ul><li>Java 8 中的接口可以通过默认方法和静态方法提供方法的代码实现。</li> <li>默认方法的开头以关键字 default 修饰，方法体与常规的类方法相同。</li> <li>向发布的接口添加抽象方法不是源码兼容的。</li> <li>默认方法的出现能帮助库的设计者以后向兼容的方式演进 API。</li> <li>默认方法可以用于创建可选方法和行为的多继承。</li> <li>我们有办法解决由于一个类从多个接口中继承了拥有相同函数签名的方法而导致的冲突。</li> <li>类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法。</li> <li>两个默认方法都同样具体时，你需要在类中覆盖该方法，显式地选择使用哪个接口中提供的默认方法。</li></ul> <p><img src="/assets/img/Optional-1.e72ffd1b.jpg" alt="Optional 类的方法1"></p> <p><img src="/assets/img/Optional-2.40823a94.jpg" alt="Optional 类的方法2"></p> <p>小结：</p> <ul><li>null 引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失。</li> <li>Java 8 中引入了一个新的类<code>java.util.Optional&lt;T&gt;</code> ，对存在或缺失的变量值进行建模。</li> <li>你可以使用静态工厂方法 Optional.empty 、 Optional.of 以及 Optional.ofNull-able 创建 Optional 对象。</li> <li>Optional 类支持多种方法，比如 map 、 flatMap 、 filter ，它们在概念上与 Stream 类中对应的方法十分相似。</li> <li>使用 Optional 会迫使你更积极地解引用 Optional 对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常。</li> <li>使用 Optional 能帮助你设计更好的 API，用户只需要阅读方法签名，就能了解该方法是否接受一个 Optional 类型的值。</li></ul> <h2 id="十一-completablefuture：组合式异步编程"><a href="#十一-completablefuture：组合式异步编程" class="header-anchor">#</a> 十一 CompletableFuture：组合式异步编程</h2> <p>两种趋势不断地推动我们反思我们设计软件的方式。第一种趋势和应用运行的硬件平台相关，第二种趋势与应用程序的架构相关，尤其是它们之间如何交互。</p> <p><img src="/assets/img/Concurrency-and-parallelism.22f7cac5.jpg" alt="并发和并行"></p> <p><img src="/assets/img/future-async.cfdc4822.jpg" alt="使用 Future 以异步方式执行长时间的操作"></p> <p>CompletableFuture 具有一定的优势，因为它允许你对执行器（ Executor ）进行配置，尤其是线程池的大小，让它以更适合应用需求的方式进行配置，满足程序的要求。</p> <p>如果线程池中线程的数量过多，最终它们会竞争稀缺的处理器和内存资源，浪费大量的时间在上下文切换上。反之，如果线程的数目过少，正如你的应用所面临的情况，处理器的一些核可能就无法充分利用。</p> <p><mjx-container jax="SVG" class="MathJax"><svg xmlns="http://www.w3.org/2000/svg" width="42.812ex" height="2.262ex" viewBox="0 -750 18922.9 1000" style="vertical-align:-0.566ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="4E" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(888, 0)"><path data-c="74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(1249, 0)"><path data-c="68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(1825, 0)"><path data-c="72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2276, 0)"><path data-c="65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(2742, 0)"><path data-c="61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(3271, 0)"><path data-c="64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(3791, 0)"><path data-c="73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mo" transform="translate(4537.8, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(5593.6, 0)"><path data-c="4E" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(6481.6, 0)"><path data-c="43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(7196.6, 0)"><path data-c="50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(7947.6, 0)"><path data-c="55" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(8936.8, 0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(9937, 0)"><path data-c="55" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mi" transform="translate(10704, 0)"><path data-c="43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mi" transform="translate(11419, 0)"><path data-c="50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(12170, 0)"><path data-c="55" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path></g><g data-mml-node="mo" transform="translate(13159.2, 0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mo" transform="translate(14159.4, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(14548.4, 0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(15270.7, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(16270.9, 0)"><path data-c="57" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="TeXAtom" transform="translate(17318.9, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(17818.9, 0)"><path data-c="43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(18533.9, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p> <p>其中：</p> <ul><li>N CPU 是处理器的核的数目，可以通过 Runtime.getRuntime().availableProce-ssors() 得到</li> <li>U CPU 是期望的 CPU 利用率（该值应该介于 0 和 1 之间）</li> <li>W/C 是等待时间与计算时间的比率</li></ul> <p>使用并行 API 的建议：</p> <ul><li>如果你进行的是计算密集型的操作，并且没有 I/O，那么推荐使用 Stream 接口，因为实现简单，同时效率也可能是最高的</li> <li>反之，如果你并行的工作单元还涉及等待 I/O 的操作（包括网络连接等待），那么使用 CompletableFuture 灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者 W/C 的比率设定需要使用的线程数。</li></ul> <p>小结：</p> <ul><li>执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度。</li> <li>你应该尽可能地为客户提供异步 API。使用 CompletableFuture 类提供的特性，你能够轻松地实现这一目标。</li> <li>CompletableFuture 类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常。</li> <li>将同步 API 的调用封装到一个 CompletableFuture 中，你能够以异步的方式使用其结果。</li> <li>如果异步任务之间相互独立，或者它们之间某一些的结果是另一些的输入，你可以将这些异步任务构造或者合并成一个。</li> <li>你可以为 CompletableFuture 注册一个回调函数，在 Future 执行完毕或者它们计算的结果可用时，针对性地执行一些程序。</li> <li>你可以决定在什么时候结束程序的运行，是等待由 CompletableFuture 对象构成的列表中所有的对象都执行完毕，还是只要其中任何一个首先完成就中止程序的运行。</li></ul> <h2 id="十二-新的日期和时间-api"><a href="#十二-新的日期和时间-api" class="header-anchor">#</a> 十二 新的日期和时间 API</h2> <p>TemporalField 是一个接口，它定义了如何访问 temporal 对象某个字段的值。 ChronoField 枚举实现了这一接口，所以你可以很方便地使用 get 方法得到枚举元素的值。</p> <p><img src="/assets/img/time-lib-1.3a22e456.jpg" alt="日期时间类1"></p> <p><img src="/assets/img/time-lib-2.3fab0eab.jpg" alt="日期时间类2"></p> <p><img src="/assets/img/time-gernal-class.dc2e9166.jpg" alt="表示时间点的日期_时间类的通用方法"></p> <p>![TemporalAdjuster 类中的工厂方法](imgs/java8-in-action/TemporalAdjuster 类中的工厂方法.jpg)</p> <p>小结：</p> <ul><li>Java 8 之前老版的 java.util.Date 类以及其他用于建模日期时间的类有很多不一致及设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名。</li> <li>新版的日期和时间 API 中，日期  时间对象是不可变的。</li> <li>新的 API 提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求。</li> <li>你可以用绝对或者相对的方式操纵日期和时间，操作的结果总是返回一个新的实例，老的日期时间对象不会发生变化。</li> <li>TemporalAdjuster 让你能够用更精细的方式操纵日期，不再局限于一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器。</li> <li>你现在可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期  时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的。</li> <li>你可以用相对于某个地区/位置的方式，或者以与 UTC/格林尼治时间的绝对偏差的方式表示时区，并将其应用到日期  时间对象上，对其进行本地化。</li> <li>你现在可以使用不同于 ISO-8601 标准系统的其他日历系统了。</li></ul> <h2 id="十三-函数式思考"><a href="#十三-函数式思考" class="header-anchor">#</a> 十三 函数式思考</h2> <p>在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用。你可以把它看成一个黑盒，它接收输入并产生一些输出。</p> <p><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAAEAYABgAAD//gAfTEVBRCBUZWNobm9sb2dpZXMgSW5jLiBWMS4wMQD/2wCEAAUFBQgFCAwHBwwMCQkJDA0MDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0BBQgICgcKDAcHDA0MCgwNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDf/EAaIAAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKCwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoLEAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+foRAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/AABEIAHgBvwMBEQACEQEDEQH/2gAMAwEAAhEDEQA/APsugAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAG5oAM0AGaADNABmgAzQAZoAM0AGaADNABmgAzQAZoAM0AGaADNABmgCvdyNFDI6nDKjEH3CkigDwnSrzX9RtIrp9avUaZQ5VLfStoz2XdpzNgdssT6k0AaGNd/6Dl/8A+A+k/wDytoAMa7/0HL//AMB9J/8AlbQAY13/AKDl/wD+A+k//K2gAxrv/Qcv/wDwH0n/AOVtABjXf+g5f/8AgPpP/wAraADGu/8AQcv/APwH0n/5W0AGNd/6Dl//AOA+k/8AytoAMa7/ANBy/wD/AAH0n/5W0AGNd/6Dl/8A+A+k/wDytoAMa7/0HL//AMB9J/8AlbQAY13/AKDl/wD+A+k//K2gAxrv/Qcv/wDwH0n/AOVtABjXf+g5f/8AgPpP/wAraADGu/8AQcv/APwH0n/5W0AGNd/6Dl//AOA+k/8AytoAMa7/ANBy/wD/AAH0n/5W0AGNd/6Dl/8A+A+k/wDytoA6PwJqOozXl/ZaheS362wtmieaO2jdfNWQuP8ARoLdSMqMblJHrQB6XmgAzQAZoAM0AGaADNABmgAzQAZoAM0AGaADNABmgAzQAZoAM0AGaAHUABoAZQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAVb7/AI9pf+ub/wDoJoA8S8Nf8gy2/wCuS0AblABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBZ8C/8hfVf9yx/wDQJ6APUqACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgB9AAaAGUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFAFW+/49pf8Arm//AKCaAPEvDX/IMtv+uS0AblABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQBZ8C/wDIX1X/AHLH/wBAnoA9SoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAH0AIx2gnk4BPHJ/Ad6APMtN8eG4t7m7liYxrPOlrsjZcpG3lwrIWfLSTyK7JtVR5ZXIB5IBu+H/FEeoN9gvWii1SNcyQRtlTxndET99RnDEchgQQKANnV9TXSY45n2hHuIIWLHGPPlWFSPcO68emaANWgAoAKACgAoAKACgAoAKACgAoAKACgAoAq33/AB7S/wDXN/8A0E0AeJeGv+QZbf8AXJaANygAoAKAGSSLChdztVQST6AdaAKNjqS34LIkiLgFWkQqGB6EZ/PBwfagDQz2oAQMM4BGfSgBSwXgkAnpQBDJcRwukbsA0hIQeuAWP6AmgBbiYW8Ty4Zwis21Blm2gnao7scYA7nigB8b71DYK5AODwRnsR2PrQA4MD0IoAAwJwCM+lAC0AFABQAUAWfAv/IX1X/csf8A0CegD1KgAoAKACgAoAKACgAoAKACgAoAKAAnHNAHnNh46EhvJriNzbW8zxwlImDEIAAHLN8zzSZSIKo5GG9aANHw/wCLFu3XTtUaG21XaGMMb5Rww3gQsT87IpCyr95XBOPLaNmADU/FMlta6jNBGofTZo4VLksrl1hYsVXaQAJsY3ckZyKANyHV9+oHTCh3JaxXJkz8v7ySWMKF65BiJznoQKANygCveDMEgyy/u3+ZBlx8p5Ud2HVR64oA+Zo7b7Abk6Yt3FFBcWFtEJ9gYxm2iT5o2UsWKA4YkEKzZGWNAHX+Bby6utUgF1natpMUJQLu/wCPfLZCjdySCR9O1AHR6/pDePrj7IxaPSrIM4kUlftF7tKxFCOsVrkybujz7NuRGSQDQ8J+ME1NjpGo/wCj6zaDbPCwK+Zt48+HPDxSfeG0nbnaelAHeUAFAHIS2viMuxjuLIJk7QYZCQM8And1x1oAj+y+Jf8An5sf+/Mn/wAVQAfZfEv/AD82P/fmT/4qgA+y+Jf+fmx/78yf/FUAH2XxL/z82P8A35k/+KoAPsviX/n5sf8AvzJ/8VQAfZfEv/PzY/8AfmT/AOKoAPsviX/n5sf+/Mn/AMVQAfZfEv8Az82P/fmT/wCKoAPsviX/AJ+bH/vzJ/8AFUAUtSsvFL2k6w3NmZDDIE2xSBtxQ7dpLYDZxgnoeaAON8F6X49srNv+EkvLSWMRN+7KF58bT1lTaucdtvXuaAIvDP8AyDLb/rktAG5QAUAFAGNr4iNjKs4ZlKkAKHJLfw8Rgt1/D1oAxY7a3m0aaKyWQP8AZiMYlRvNEXy7d+05DYxt4zQA+G+guNVheESlTaXCSOUlVN4e2ZFO4AbwiykHHqM5OKAMrT4obWC3uYhMJGvpFLMJy3lGaXCkMMiPYUxkBQMc5zQBozramS4TUxL5zO3llVmP7o/6vyTGCFIH3sENvyTxigBdTsbZWsZ7hJDHECjFvMLqPJYLvEZJ3bsBjz8x5OKAL2pT2j6cwxJ5RRhGAk27cFO3hR5g56FsUAQtdNeaUPs3mFkEKygK6SbAyecF3hSXMe8Aj+Loc0ARWv2b7QGsVkW2ET/aMrKqkY+TAcBjJnOSo3Y6nNAGZpUUVlFpcqCYSyyFJmYTFiDbzgiXcDhfO8rBYAA4wQM0Aeh0AFABQAUAZnhuHVJNY1L+zJYIlEdlv85Gck7JsbdpGO+aAO7+y+Jf+fmx/wC/Mn/xVAB9l8S/8/Nj/wB+ZP8A4qgA+y+Jf+fmx/78yf8AxVAB9l8S/wDPzY/9+ZP/AIqgA+y+Jf8An5sf+/Mn/wAVQAfZfEv/AD82P/fmT/4qgA+y+Jf+fmx/78yf/FUAH2XxL/z82P8A35k/+KoAPsviX/n5sf8AvzJ/8VQAfZfEv/PzY/8AfmT/AOKoA85/sf4i/wBvzTQXtpHpp8vAkQtGSFG7y4x86nPBJbGecUAe4WizJEouSrSgfMUBCk+oB5FAEsv3G6j5TyOo47e/pQB83La/ZLq4OnC8RIp7CNfPCKz+aSHJjZSzFtzbSduAx45oA1vBd9eXeo6Yt3koEdkZowu5jYqztuCgMQzEZH3enrQBp63LY3mlarNMYo7k3rIQsrIWEcsEasyeZgtsUAnb0GaAOssns7fX4Y7Eo5utOmMrCUyEC2mg8pRlm2gm6lJ9cD0NAHodAAaAMe40OxujIZoI5DM6SSblB3OihEY+pVQAD2FACQaFYWsqzwwRpIkPkKyqBiLr5Y/2eBx7CgDVVQgCqAAOgHAFAEfkR7/N2r5mMbsDdj0z1x7UAS0AFABQAUAFABQAUAFABQAUAFABQAUAVb7/AI9pf+ub/wDoJoA8S8Nf8gy2/wCuS0AblABQAUAFABQAdKACgAoAKACgAoAOlABQAUAFABQAUAWfAv8AyF9V/wByx/8AQJ6APUqACgAoAKACgAoAKACgAoAKACgAoAKAMyfRrK5Z3mhjdpSjOWUHcY/9WT67e3pQBFb+H9PtJIJoLeON7OJoYCqgeXG20Mi46AhQPpn1NAGj9lhGf3afMST8o5J5JPHU0AMFjbiZbkRoJkRo1kCgMqOUZ1BxkKxjQkdCVHpQBdoADQAygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAq33/HtL/1zf8A9BNAHiXhr/kGW3/XJaANygAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAs+Bf+Qvqv+5Y/wDoE9AHqVABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQA+gANADKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgCrff8AHtL/ANc3/wDQTQB4l4a/5Blt/wBcloA3KACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgCz4F/5C+q/wC5Y/8AoE9AHqVABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQA+gAoAbigAxQAYoAMUAGKADFABigAxQAYoAMUAGKADFABigAxQAYoAMUAGKAILqJpYXjXq6Mo+pBAoA+e9PsPGGmW6Wi6JHKIBsEg1O2UOAeG2lCVz1wTkUAXMeMf8AoAp/4Nbb/wCN0AGPGP8A0AU/8Gtt/wDG6ADHjH/oAp/4Nbb/AON0AGPGP/QBT/wa23/xugAx4x/6AKf+DW2/+N0AGPGP/QBT/wAGtt/8boAMeMf+gCn/AINbb/43QAY8Y/8AQBT/AMGtt/8AG6ADHjH/AKAKf+DW2/8AjdABjxj/ANAFP/Brbf8AxugAx4x/6AKf+DW2/wDjdABjxj/0AU/8Gtt/8boAMeMf+gCn/g1tv/jdABjxj/0AU/8ABrbf/G6ADHjH/oAp/wCDW2/+N0AGPGP/AEAU/wDBrbf/ABugAx4x/wCgCn/g1tv/AI3QB2Pw+0vV7a4vr7WbRdPa6+zrHEtxHcEiFZAzF4wAMlwACM8H2oA9OxQAYoAMUAGKADFABigAxQAYoAMUAGKADFABigAxQAYoAMUAGKADFADqACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoA4PxJIRrOnxk3BjNrqLmK3lljaVkNkEH7t49xy5C722KW3EqMkAHGeHb6/uNV/sSWcT3EEs82oBru7H2eF2ZoLe0ZbhftDKHQF2jPlrG4uCkskaUAdZ4MkuIvDhkgcy3Cy6gUa5kllGUvbkKGZnMhVVUAKGHAABHWgC/wCFtav/ABF4bs9UUQJfX1pDMcq/kI8oUs2wPvZEBLCPzFZ8BPNTdvABH4R1LWLi51Cw1gwTjT5okhvLeJ4EnEkKyujQvLNskgLKrlZGUh16MGFAHTaql9JD5emPDDOxA82dGlSNcElvJSSIytkBVXzYwN28lguxwDB8E6rqWq2UrausXn293cWyzQKyQ3McEmxbiNHZ2QOQyld7jcjFWKkUAdhQAUAFAASB14z0oA5jXtVuFzpujhZNSmXhmGYrRG4+0XGOgUZMUOQ9w42LiMSyxAHG+HNetfCulxO5uptGJlC38weWWKVJXjn+2hd7rHJOsksdwo8lA5jkEKpG0oBr+KdZgubWCS2kuRFOrXFrqFgyyRiSBTKIZCCUKXSK0UYkWSGViYzsl8ncAcfq8N7qmn69LFdyG48pILMpevbRtNBZxi4liHnRRIr3JkjLttXdExJC/MQD0vR9Vudes1ubaF9PUkeX9r8i586IoCsiNaX0i7WJGHaUs20nYQyvQB59pmpz+JNdn1RLkSWujmTT7Yw2V5JDLO4je8lIhmZW8vEdvGWdhlZnVAGRyAd54b1KTWUbVVuhNYyK8axG0e18uSCWSOWTMrtLyysjB/kwism35y4ByfgU/wDCRtqmvW8sttJf37QhjGNyW1pGkNsI1lDovmLm5YtGTumKMPkFAE/w/ElzaW2t6nqFzPeX4lhEc0yJAxWWXCw2saRRCQJEW3Ihk2q5J27hQBm6trMF54iubiSS5ht/DVihDwKpDzX0zJMQr7lm8pLYQqNjqsjXAO2WNaALmta5O8UtvZXd9BNHqGn2EzSQ2qMgv5bdWeE/Z/8AWJDPuRmBCybSyOvDAGxr8l1YXVhaxTTuLlZUllKTSN+4i3CQxWnlLvkY4chVTptVehAMPSdUvbd0uGMnmXWsHTn877Vsa1hjuHSSO3uJW8iRiuGdMBiMsGwFABS0vxCfC/w/TUl3SXEVpN5K8uzTbpSvBOSqYMknZIUduFQ4AMlYTpU2ipZjfpulPFYQvcO4Mt9cxN51y+GIcWqK0e3ds+0XE6AqbcCgD2LS7q4ubicPcWk8UWxPLtw3mQy43sJmMzj50eNlTy42UfNlw4wAeQRajeW/hJb9Dftc/aFX7QbokFW1MRFQrXWQpiJiUeWNoxjaAGAB18okTxVpkQ+2W8RsNUkaOS6Z45XSTTUQsguJlbyxNIRuC4ZgRnHABQvdfvftUutrBG0WnXY0iKI3csYdrq+tIJLiRFt2QkbotgJfywspBJkAAA6bVb/R4dR8SxIlyl3c28VtDJdSoiQLJFZxkRrFIiNM7yXLOPnKSRo67o9tAHV+Idc07TpTFfNcoYLWS8cwNOqpbpJHHLI5gdSwj3BiuGYIHZFOCKAOLu9Sg1e5fTLe5vbRReLaK9pcXd1czKba3uTOnzPHa2yrcIklxJHMASNrROyNQBp6/rslxotjqOjvJcJcrE8Ss2ya7jki5R42hZdrRM080p8ryBH5i5GVIB5v4fvLm/stM01gX+0nSmmR7i5iEMdnBHcRAI0AjSKeX7IGmgaZriWeRXbYgWEA9v8AC2t3XiCGS8mhit7fzZooNkrSO32eea3kd8xRqEdovMiKliY2G4KeKAOooAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPPfEbJ/wAJHpcUnmBXs9Vz5XmbuG07vF86jnkqR6ZGaAMqLRba51A2+p6ZvsUEc9oyrJLBbTQkKfLie1hmtpLhWDSLGZoJBExdg7v5gBo+CZQnhkvtcjzdSwqo7Of9OuwAI1UuSeOAufagCHwRcv4d8HaeL22u/NtLS3gmt0tpnuFcBY3xAE8xwpO5iitlQSu7FAFXw94WFtqOqXuhiXR7LUreAIPI8r/TlaczXcdncIBH+7eFCJIUErq5KFVV2AOhzN4ctPK1qa811bqbyyyWCSmNHQ5EkFjBkw5U7nMbnLgH5egBS+H/AIcXw6L9bSN7XTbq88+xtXDL5MZghWUrG3zQJLcLLIkJClEKkojMUUA9CoAa6CRSjdGBBwSDg8HBGCPqCCO1AGR/YFp/02/8Cbn/AOO0AV5/Cum3RQzxNL5Miyx+ZNO+yRPuSKGkIV1ydrDkZODzQBuQ28duCIlVAzFm2gDLN1Y46se5PJ7mgDhvhid/h23PrJefre3FAC+N5XifSoNwS1n1SBZ12EjbDFPdRln3BY41mt4i2VwcBcgEggHI+M1udTM0Gh2sl3p95EsWozwRRho4wyrI9g0jx/aZ5bYvC/k71j2RujmaPyJgDvtPlsfE2nLBprTW9kn7h4/IntJAiDaYB5yRSRY+45RQ6jKo6NhgAcX4WsYrUarIkiWdpbapcRgebcQRRJHFboBiKeKJEUAD7owBycDgA1/hpHBqXhiJHKzwTTagCQxZJYzqF1zu3Euki+rMHQ/MWDHIBS8JNpjrqLal9lz/AG1qSp9o8rOElVWC+Z2GBnHtmgCv8ORo1vpmn2k0duNQYzsgMKmVWSaRgWcIfKbaQY97IXH+r3YOAB9/ox1fWNZ0uzKQFtK0eNSQdqk3mrSsxABJJ5J7sxyx5JoAr+KbaHRpVSe7jlvNV1zRZ44G2RyFYLmxhby03FpQqwmR2VQEH3uhYgFT4hQXlzqF7FYeYbj+wwYVijneTzftMwUx+S67JOwdg3oO9AD7Cwij1W/uruaOzttOvrC7eR45IISq2E0bD99IfL5lBeQtjAGR0oAjs44ZfhzPc4DmPSdUaJ+o2vHc/Ovb5kxtcc7GIU7XbIB0Hi+ILZ6JFEkZB1OyCowxGf3E5wQFOBx2U/SgDrYXm0Zbi6vRaw2iIrKtuj+YCobfvPAlLkqIlSNWB+X5ywwAeY6j4bbSfBcUV35yXW6yeaMXE21JJr+CSRAiy+X8jSFcquMjcvODQBuyyWq+NNPtbZ5Xmg03VGnSSSeRo1km0wRNiZm2pI0cgVk+Vyh5O0YAOZmszc2l/ttp5JW8SQsrKjlDGmq2e5sA4KhEcsdhAAJJ4JABseNY9Ps7l7OGZ/7R1+80hRZnO1ha3kLT3USbR921X/SZQWXbbxK21hyAaPiSC5uvEUcVtM1ru0uVZJFtjcZja6h3RrlXiR3AIDyRzKoBJhfIoAwtA0K9sri61KzNzpc0uqIxhnWW4S6sI4bW3dZQvmbXYxTS20qlZUyiyARs0agEFjA0vgHTJIZ/skr6XaW5K7VllhdIvOggYQzT/aJYlZIBCA3mlHwxRcAEVpe317pN5bAXX9vy3SmzsriNA9mLZ4pbLzXRFjNoqpFPczB2iaSSaCJnmIRwD0H4e39nLpMOnW/mRXGmRx211BOuy4inRBvMq9GMjEyCVC0UobfGxU0AdzQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAJsGQ2BuAIBxyAcZAPocDI74HpQAtAB0oAKACgAoAKACgAoAKACgAoAZHEkKhI1CKvAVQAB9AOBQA8gHg0AFABQA1UVMhQBkknAxknqT7nue9ADYYUt0WKJVjRAAqqAqqB0AAwAB2AGKAEhgjtwVhRYwzM7BVCgu5LOxwBlmYlmY8sSSSTQBLQBGsEaO0qqqyOFDOAAzBc7QzYyQu5toJ4ycdTQA2W2inZHkRHaFt8ZZQSjbSu5CQSrbWZcjB2sRnBNAEu0A7sDOMZ74HQfqfzoAR0V1KsAysCCCMgg8EEHggjqKAI2toXhNsyIYSnlmMqChQjaUKY27Cvy7cYxxjFABJbxTbPMRX8pg6blB2MAVDLkfKwDEAjBwSM4JoAlZQwwwBAIPPPIOQfqCAR6HmgBSAeD/nvQA3y1Db8DdjG7AzgHOM9cZJOOmTQA6gBpjUsHIBZQQDgZAOMgHqAcDOOuBnpQA6gAoAj8iPcJNq71G1WwNwU9VBxkDjoOKAFSJIyxRVUucsQACxxjJx1OABk84FAD6ACgAoAKACgAoAKACgAoAKACgD/9k=" alt="一个没有任何副作用的函数"></p> <p>要被称为函数式，函数或者方法不应该抛出任何异常。</p> <p>如果一个函数只要传递同样的参数值，总是返回同样的结果，那这个函数就是引用透明的。</p> <p>小结：</p> <ul><li>从长远看，减少共享的可变数据结构能帮助你降低维护和调试程序的代价。</li> <li>函数式编程支持无副作用的方法和声明式编程。</li> <li>函数式方法可以由它的输入参数及输出结果进行判断。</li> <li>如果一个函数使用相同的参数值调用，总是返回相同的结果，那么它是引用透明的。采用递归可以取得迭代式的结构，比如 while 循环。</li> <li>相对于 Java 语言中传统的递归，“尾  递”可能是一种更好的方式，它开启了一扇门，让我们有机会最终使用编译器进行优化。</li></ul> <h2 id="十四-函数式编程技巧"><a href="#十四-函数式编程技巧" class="header-anchor">#</a> 十四 函数式编程技巧</h2> <p>满足下面任一要求就可以被称为高阶函数（higher-order function）：</p> <ul><li>接受至少一个函数作为参数</li> <li>返回的结果是一个函数</li></ul> <p>科里化是一种将具备 2 个参数（比如， x 和 y ）的函数 f 转化为使用一个参数的函数 g ，并且这个函数的返回值也是一个函数，它会作为新函数的一个参数。后者的返回值和初始函数的返回值相同，即 f(x,y) = (g(x))(y) 。</p> <p>我希望对树结构的更新对某些用户可见（当然，这句话的潜台词是其他人看不到这些更新）。”那么，要实现这一目标，你可以通过两种方式：第一种是典型的 Java 解决方案（对对象进行更新时，你需要特别小心，慎重地考虑是否需要在改动之前保存对象的一份副本）。另一种是函数式的解决方案：逻辑上，你在做任何改动之前都会创建一份新的数据结构（这样一来就不会有任何的对象发生变更），只要确保按照用户的需求传递给他正确版本的数据结构就好了。</p> <p>小结：</p> <ul><li>一等函数是可以作为参数传递，可以作为结果返回，同时还能存储在数据结构中的函数。</li> <li>高阶函数接受至少一个或者多个函数作为输入参数，或者返回另一个函数的函数。Java 中典型的高阶函数包括 comparing 、 andThen 和 compose 。</li> <li>科里化是一种帮助你模块化函数和重用代码的技术。</li> <li>持久化数据结构在其被修改之前会对自身前一个版本的内容进行备份。因此，使用该技术能避免不必要的防御式复制。</li> <li>Java 语言中的 Stream 不是自定义的。</li> <li>延迟列表是 Java 语言中让 Stream 更具表现力的一个特性。延迟列表让你可以通过辅助方法（ supplier ）即时地创建列表中的元素，辅助方法能帮忙创建更多的数据结构。</li> <li>模式匹配是一种函数式的特性，它能帮助你解包数据类型。它可以看成 Java 语言中 switch 语句的一种泛化。</li> <li>遵守“引用透明性”原则的函数，其计算结构可以进行缓存。</li> <li>结合器是一种函数式的思想，它指的是将两个或多个函数或者数据结构进行合并。</li></ul> <h2 id="十五-面向对象和函数式编程的混合：java-8-和-scala-的比较"><a href="#十五-面向对象和函数式编程的混合：java-8-和-scala-的比较" class="header-anchor">#</a> 十五 面向对象和函数式编程的混合：Java 8 和 Scala 的比较</h2> <p>Java 8 和 Scala 都是整合了面向对象编程和函数式编程特性的编程语言，它们都运行于 JVM 之上，在很多时候可以相互操作。
Scala 支持对集合的抽象，支持处理的对象包括 List 、 Set 、 Map 、 Stream 、 Option ，这些和 Java 8 非常类似。不过，除此之外 Scala 还支持元组。
Scala 为函数提供了更加丰富的特性，这方面比 Java 8 做得好，Scala 支持：函数类型、可以不受限制地访问本地变量的闭包，以及内置的科里化表单。
Scala 中的类可以提供隐式的构造器、getter 方法以及 setter 方法。
Scala 还支持 trait，它是一种同时包含了字段和默认方法的接口。</p> <h2 id="其它新特性"><a href="#其它新特性" class="header-anchor">#</a> 其它新特性</h2> <p>Java 8 在两个方面对注解机制进行了改进，分别为：</p> <ul><li>你现在可以定义重复注解</li> <li>使用新版 Java，你可以为任何类型添加注解</li></ul> <p>从 Java 8 开始，注解已经能应用于任何类型</p> <p><img src="/assets/img/collections-add-methods.c76e7892.jpg" alt="集合类和接口中新增的方法"></p> <p>Files 类最引人注目的改变是，你现在可以用文件直接产生流。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次修改:</span> <span class="time">8/22/2019, 12:21:44 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/" class="prev router-link-active">
        日志
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.cccfd8e7.js" defer></script><script src="/assets/js/2.9de5c6c1.js" defer></script><script src="/assets/js/4.a7183ff4.js" defer></script>
  </body>
</html>
