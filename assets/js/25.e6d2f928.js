(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{311:function(v,_,l){"use strict";l.r(_);var i=l(6),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("p",[v._v("在适用"),l("code",[v._v("@Async")]),v._v("注解后，还需在启动类上加上"),l("code",[v._v("@EnableAsync")]),v._v("的注解，对于异步线程池，我们可以实现"),l("code",[v._v("AsyncConfigurer")]),v._v("来进行自定义配置")]),v._v(" "),l("p",[v._v("异步线程池有两种拒绝策略：")]),v._v(" "),l("ul",[l("li",[v._v("AbortPolicy：直接抛出异常")]),v._v(" "),l("li",[v._v("CallerRunsPolicy：主线程直接执行该任务，执行万之后尝试添加下一个任务刀线程池中，这样可以有效的降低向线程池内添加任务的速度")])]),v._v(" "),l("p",[v._v("限流算法：")]),v._v(" "),l("ol",[l("li",[v._v("令牌桶")]),v._v(" "),l("li",[v._v("漏桶")])]),v._v(" "),l("p",[v._v("Guava Cache 的优点：")]),v._v(" "),l("ul",[l("li",[v._v("本地缓存，读取效率高，不受网络因素影响")]),v._v(" "),l("li",[v._v("拥有丰富的功能，操作简单")]),v._v(" "),l("li",[v._v("线程安全")])]),v._v(" "),l("p",[v._v("Guava Cache 的不足之处：")]),v._v(" "),l("ul",[l("li",[v._v("缓存为本地缓存，不能持久化数据")]),v._v(" "),l("li",[v._v("单机缓存，受机器内存限制，应用重启会数据会丢失")]),v._v(" "),l("li",[v._v("分布式部署时无法保证数据的一致性")])]),v._v(" "),l("p",[v._v("常用的分片算法：")]),v._v(" "),l("ul",[l("li",[v._v("范围分片")]),v._v(" "),l("li",[v._v("取模分片")]),v._v(" "),l("li",[v._v("Hash 分片")]),v._v(" "),l("li",[v._v("时间分片")])]),v._v(" "),l("p",[v._v("常见的分布式 Id 生成方式")]),v._v(" "),l("ul",[l("li",[v._v("采用 Twitter Snowflake 算法实现")]),v._v(" "),l("li",[v._v("更加机器名称最后的数字编号取得工作进程 id")]),v._v(" "),l("li",[v._v("更加机器 ip 获取工作进程 id，如果线程机器的 ip 二进制表示的最后 10 位不重复，建议使用此种方式")])])])}),[],!1,null,null,null);_.default=e.exports}}]);