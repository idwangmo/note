---
title: 左耳听风
sidebar: auto
---

## 技术变现

不应该将时间浪费在无尽的功能上。

技能变现：

1. 先有一个个小的成功
2. 关注有价值的东西
   1. 关注市场需求
   2. 关注技术趋势
3. 找到能体现价值的地方
4. 提高动手能力
5. 关注技术付费点
   1. 能帮别人“挣钱”
   2. 能帮别人“省钱”
6. 提升自己的能力和经历
7. 找到有价值的信息源
8. 输出观点和价值观
9. 朋友圈很重要

## 安全

数据泄露的一般原因：

1. 利用程序框架或者库的已知漏洞
2. 暴力破解密码
3. 代码注入
4. 利用程序日志不小心泄露信息
5. 社会工程学

数据管理上可能出现的问题：

1. 只有一层安全
2. 弱密码
3. 向公网暴露了内部系统
4. 怼系统技术打安全补丁
5. 安全日志被暴露
6. 保存了不必要的保存的用户数据
7. 密码没有合理的被散列

避免安全问题的最佳实践：

1. 时刻追踪所使用软件的产品版本和最新的安全声明
2. 建立一个流程快速地部署带有安全补丁的软件产品发布
3. 认识到所有复杂软件都有漏洞
4. 建立多个安全层
5. 针对公网资源，建立怼异常访问模式的监控机制

技术上的安全做法：

1. 隔离关键数据
2. 密钥要做到随机生成，最好是针对不同用户的数据有不同的密钥，并且能够自动化更新

## 技术领导力

### 拥有技术领导力

1. 要吃透基础技术
    * C 语言
    * 编程范式
    * 算法和数据结构
    * 计算机系统原理
    * 操作系统原理和基础
    * 网络基础
    * 数据库原理
    * 分布式技术架构
2. 提高学习能力
3. 坚持做正确的事情
    * 提高效率的事
    * 自动化的事
    * 掌握前沿技术
    * 知识密集型的事
    * 技术驱动的事
4. 高标准要求自己

### 书单

* 代码大全
* 程序员的修炼之道
* 计算机的构造和解释
* 算法导论
* 设计模式
* 重构
* 人月神话
* 代码整洁之道
* Effective C++ / More Effective C++
* Unix 编程艺术 / Unix 高级环境编程
* C++ 软件性能优化
* Machine Learning is Fun!
* C++ 语言的设计和演化
* 吴恩达的 Course 课程
* Tom Mitchell 机器学习课程
* Machine Learning 101
* 机器学习

[软件优化相关资料](https://www.agner.org/optimize/)

## Leader

### Leader 需要的素质

* 赢得他人的信任
* 开放心态 + 倾向的价值观
* 保持热情和冲劲
* 能够抓住重点，看透事物的本质
* 描绘令人激动的方向，提供令人向住的环境
* 甘当铺路石，为他人创造机会

## 编程

### 错误处理

* 传统错误检查
* 多返回值
* 资源清理
* 异常捕捉处理

可以参考的原则：

* 对于不期望发生的事情，我们可以使用异常捕捉
* 对于看恩纳个发生的事情，使用返回码

可以参考的最佳实践：

* 统一分类的错误字典
* 同类错误定义最好可以扩展
* 定义错误的严重程度
* 错误日志的输出最好使用错误码，而不是错误信息
* 忽略错误最好有日志
* 同一个地方的错误最好打印一个错误及错误的次数
* 对已同类的错误，要用一样的模式
* 尽可能再错误发生的地方处理错误
* 在处理错误的时，总要清理已分配的资源
* 不推荐再循环体中处理错误
* 不要将大量代码放到`try`语句中
* 为定义的错误提供清楚的文档以及每种错误的代码示例
* 对于异步方式，推荐使用`Promise`
* 对于分布式系统，推荐使用`APM`相关软件

### 故障处理

在故障发生时，最重要的是快速恢复故障，而快速恢复故障的前提是快速定位故障。

恢复系统的常用手段：

* 重启和限流
* 回滚操作
* 降级操作
* 紧急更新

最重要的是降低故障造成的影响

### 分布式

使用分布式的两个主要原因：

1. 增大系统容量
2. 加强系统可用

#### 亚马逊分布式的总结

1. 分布式服务的架构需要分布式的团队架构
2. 分布式服务查错不容易
3. 没有专职的测试人员，也没有专职的运维人员，开发人员做所有的事情
4. 运维优先，崇尚简化和自动化
5. 内部服务和外部服务一致

#### 分布式系统中需要注意的问题

1. 异构系统的不标准问题
2. 系统架构中的服务依赖问题
3. 故障发生的概率更大
4. 多层架构的运维复杂读更大

#### 增强系统可用的方法

* 大流量处理
* 关键业务保护

#### 提高架构性能

* 缓存系统
* 负载均衡
* 异步调用
* 数据镜像
* 数据分区

#### 提高架构稳定性

* 服务拆分
* 服务冗余
* 限流降级
* 高可用架构
* 高可用运维

#### 分布式系统的关键技术

* 服务治理
* 软件架构管理
* DevOps
* 自动化运维
* 资源调度管理
* 整体架构监控
* 流量控制

#### 分布式系统的五个关键技术

* 全栈系统监控
* 服务 / 资源调度
* 流量调度
* 状态 / 数据调度
* 开发和运维自动化

### 监控

#### 好的监控系统的特征

* 关注于整体应用的 SLA
* 关联指标聚合
* 快速定位故障

#### 好的监控系统的需要做的东西

* 服务调用链跟踪
* 服务调用时长分布
* 服务的 Top N 视图
* 数据库操作关联
* 服务资源跟踪

### 服务调度

微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要优依赖环。

### 流量调度

#### 流量调度系统需要完成的事

* 服务流控
* 流量控制
* 流量管理

#### 流量调度的关键技术

1. 高性能
2. 抗流量
3. 业务逻辑
4. 服务化

#### 状态数据调度小结

* 对于应用层上的分布式事务一致性，只有两阶段提交这样的方式
* 底层存储可用解决这个问题的方式是通过`Paxos`、`Raft`或`NWR`这样的算法和模型来解决
* 状态数据调度赢是由分布式存储系统来解决

### 故障

#### 处理故障的准备工作

* 建立一用户功能为索引的五福和资源全视图
* 为视图中的各个服务指定关键指标，以及一套运维流程和工具，包括应急方案
* 设定故障等级
* 故障演练
* 灰度发布系统

#### 故障复盘文档（参考）

* 故障处理的整个过程
* 故障原因分析
* Ask 5 Why
* 故障后续整改计划

#### 陈皓的总结的原则

1. 举一反三解决当下故障
2. 简化复杂、不合理的技术架构、流程和组织
3. 全面改善和优化整改系统，包括组织

## 机器学习

* 监督式学习
* 非监督式学习

## 投资自己

主动管理的不是你的时间，而是管理你的同事，管理你的信息

要学会说“不”

### 投资自己的时间

* 花时间学习基础知识，花时间读文档
* 花时间在解放自己的生存力的事情上
* 花时间在让自己成长的事上
* 花时间在建立高效的环境上

一方面，兴趣是需要保持的。另一方面，兴趣其实也是可以培养出来的。

找到学习的方法，提升自己对新事物学习的能力，才是真正靠谱的

软件工程师的主要能力的体现：

1. 提高服务的 SLA
2. 能力和资源的冲用或复用
3. 过程自动化

## 学习

学习需要持续的付出，其会让人感到痛苦，并随时想找理由放弃

学习不是努力的读更多的书，盲目追求阅读的速度和质量，这会让人产生低层次的奋斗和成长的感觉。要思辨，要实践，要归纳总结，如果只是在机械地重复某件事情，而不会有质的成长的

学习的三个步骤：

* 知识采集
* 知识缝合
* 技能转换

代码会告诉细节，书和文档是人对人说的话，代码是人对机器说的话。

理解代码的构造部分，大体如下：

1. 接口抽象定义
2. 模块粘合层
3. 业务流程
4. 具体实现
    * 代码逻辑
    * 出错处理
    * 数据处理
    * 重要的算法
    * 底层交互
5. 运行时调试

## 编程范式

编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照“方法学”一词）。

在编程世界中，我们需要处理好两件事：

* 第一件事是编程语言中的类型问题。
* 第二件事是对真实世界中业务代码的抽象、重用和拼装

类型检查系统：

* 静态类型检查是在编译器进行语义分析时进行的
* 动态类型检查系统更多的是在运行期做动态类型标记和检查相关

### 函数式编程

函数式编程有以下特征：

* `stateless`：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，你给我数据我处理完扔出来，里面的数据是不变的。
* `immutable`：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。

函数式编程的优势：

* 没有状态就没有伤害。
* 并行执行无伤害。
* Copy-Paste 重构代码无伤害。
* 函数的执行没有顺序上的问题。

函数式编程的其他好处：

* 惰性求值
* 准确性

递归的精髓是描述问题

### 面向对象

面向对象的三大特性：继承、封装、多态

二十三个经典设计摩丝的核心概念：

* "Program to an 'interface', not am 'implementation'"
* "Favor 'object composition' over 'class inheritance'"


