# 第一章


每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。


一个设计模式有四个基本要素：


1. 模式名称
2. 问题
3. 解决方案
4. 效果


设计模式是用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。


MVC通过建立一个”订购/通知“协议来分离视图和模型。视图必须保证它的显示正确地反映了模型的状态。一旦模型的数据发生变化，模型将通知有关的视图，每个视图相应地得到刷新自己的机会。


将对象分离，使得一个对象的改变能改影响另一些对象，而这个对象并不需要知道哪些被影响的对象细节。


MVC的另一个特征是视图可以嵌套。


将一些对象划为一组，并将该组对象当作一个对象使用。


MVC允许在不改变视图外观的情况下改变视图对用户输入的响应方式。


MVC的主要关心还是由Observe、Composite好Strategy三个设计模式给出的。


## 23个设计模式


Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。


Adapter：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于借口哦不兼容而不能在一起工作的那些类可以一起工作。


Bridge：将抽象部分与它的实现部分分离，使它们都可以独立地变化。


Builder：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。


Chain of Reponsibility：为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。


Command：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以支持可取消的操作。


Composite：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和复合对象的使用具有一致性。


Decorator：动态地给一个对象添加一写额外的职责。


Facade：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。


Factory Method：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。


Interpreter：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的子句。


Iterator：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。


Mediator：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。


Memento：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存状态。


Observer：定义对象的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得得到通知并自动刷新。


Prototype：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。


Proxy：为其他对象提供一个代理以控制这个对象的访问。


Singleton：保证一个类仅有一个实例，并提供一个访问它的全局访问点


State：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类


Strategy：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换


Template Method：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。


Visitor：表示一个作用于某对象结构中的各元素的操作。可以在不改变各元素的类的前提下定义作用于这些元素的新操作。


模式可以根据其目的分为创建型、结构型、或行为型。


类模式处理子类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性。


创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中。结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式。行为类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作完成单个对象所无法完成的认为。


设计模式解决的问题方法：


* 寻找合适的对象
* 决定对象的细粒度
* 指定对象接口
* 描述对象的实现


对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的**型构**


对象操作所定义的所有操作型构的集合被称为该对象的**接口**


**类型**是用来标识特定接口的一个名字


当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的**子类型**，另一个类型称为**超类型**


发送给对象的请求和它的相应操作在运行时刻的连接就称为**动态绑定**


对象通过实例化类来创建的，次对象被称为该类的实例。当实例化类时，要给对象的内部数据（由实例变量组成）分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来创建的。


新的类可以由已存在的类通过继承来定义。当子类继承父类时，子类包含该了父类所有的数据和操作。子类的实例对象包含所有子类和父类定义的数据，且它们能完成子类和父类定义的所有操作。


抽象类的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或全部操作的实现延迟加载到子类中，因此一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作。


类能够重定义父类定义的操作，重定义使得子类能接管父类对请求的处理操作。


混入类时给其他类提供可选择的接口或功能的类。


**对接口编程，而不是对实现编程**


面向对象系统中功能复用的两种最常用的技术是类继承和对象组合


**优先使用对象组合，而不是类继承**


导致重新设计的一般原因：


1. 通过显示地指定一个类来创建对象
2. 对特殊操作的依赖
3. 对硬件和软件平台的依赖
4. 对对象表示或实现的依赖
5. 算法依赖
6. 紧耦合
7. 通过生成子类来扩充功能
8. 不能方便的对类进行修改


模式和框架的区别：


1. 设计模式比框架更抽象
2. 设计模式是比框架更小的体系结构元素
3. 框架比设计模式更加特例化


选择设计模式的方法：


* 考虑设计模式是怎样解决设计问题的
* 浏览模式的意图部分
* 研究目的相似的模式
* 检查重新设计的原因
* 考虑设计中那些是可变的


# 第二章


层次结构信息的表述通常是通过一种被称为递归组合的技术来实现的。递归组合可以由较简单的元素逐渐建立复杂的元素。


获得跨越硬件和软件平台的可移植性是系统设计的主要问题之一。移植的一大障碍是不同视感标准之间的差异性。


一个平台将多个互相重叠的窗口展示在一个点阵显示器上