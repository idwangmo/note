# 算法图解

## 第一章

一般而言，应选择效率最高的算法，以最大限度地减少运行时间或占用空间

大O表示法是一种特殊的表示法，指出了算法的速度有多快

常用的5中时间表示的方法：

1. O(log n) 对数时间
2. O(n)线性时间
3. O(n* log n)
4. O(n^2)
5. O(n!)

算法运行时间并不以秒作为单位，算法运行时间是从其增速的角度度量的

一些启示：

- 算法的速度指的并非时间，而是操作数的增速。
- 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
- 算法的运行时间用大O表示法表示。
- O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。

## 第三章

每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。

调用另一个函数时，当前函数暂停并处于未完成状态。

每个函数调
用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择：

- 重新编写代码，转而使用循环。
- 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。

## 第四章

使用D&C解决问题的过程包括两个步骤：

1. 找出基线条件，这种条件必须尽可能简单。
2. 不断将问题分解（或者说缩小规模），直到符合基线条件。


实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)

缓存的数据则存储在散列表中

散列表适合用于：

- 模拟映射关系；
- 防止重复；
- 缓存/记住数据，以免服务器再通过处理来生成它们。

要避免冲突，需要有：

- 较低的填装因子；
- 良好的散列函数。

一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。

## 第七章

狄克斯特拉算法包含4个步骤：

1. 找出“最便宜”的节点，即可在最短时间内到达的节点。
2. 更新该节点的邻居的开销，其含义将稍后介绍。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径。

无向图意味着两个节点彼此指向对方，其实就是环

狄克斯特拉算法只适用于有向无环图

如果有负权边，就不能使用狄克斯特拉算法

## 第九章

动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品：

- 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。
- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值
- 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。

## 第十章

KNN用于分类和回归，需要考虑最近的邻居

特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字

能否挑选合适的特征事关KNN算法的成败