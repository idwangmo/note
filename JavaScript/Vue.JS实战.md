## Vue.JS实战

## 第二章

Vue.js最核心的功能：数据的双向绑定

在每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子

Vue的生命周期比较常见的有：

- `created`: 实例创建完成之后调用，此阶段完成了数据的观测等，但尚未挂载，`$el`还不可用
- `mounted`: el挂载到实例上后调用
- `beforeDestroy`: 实例销毁之前调用

如果将用户产生的内容使用`v-html`输出后，有可能导致XSS攻击，所以要在服务端对用户提交的内容进行处理，一般可将尖括号“<>”转义

Vue.js只支持单个表达式，不支持语句和控制流

Vue.js支持在`{{}}`插值的尾部添加一个管道符`|`对数据进行过滤

数据驱动DOM时Vue.js的核心理念，所以不到万不得已时不要主动操作DOM，只需要维护好数据

`v-bind`可以缩写成`:`，`v-on`可以直接用`@`来缩写

## 第三章

在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。

没一个计算属性都包含了一个`getter`和一个`setter`，当需要时，也可以提供一个`setter`函数，当手动修改计算属性的值就像修改一个普通数据那样时，就会触发`setter`函数，执行一些自定义的操作。绝大读书情况下，我们之后用默认的`getter`方法来读取一个计算属性，所以可以直接使用默认写法。

计算属性小技巧：

1. 计算属性可以以来其他计算属性
2. 计算属性不仅可以依赖当前Vue的实例数据，还可以依赖其他实例的数据

计算属性是基于它的依赖缓存的，一个计算属性所依赖的数据发生变化时，它才会重新取值

使用计算属性还是`methods`取决于是否需要缓存，当遍历大数组和大量计算时，应当使用计算属性，除非不希望得到缓存

## 第四章

`:class`等同于`v-bind:class`，其内的表达式每项为真时，对应的类名就会加载。当`:class`表达式过长或逻辑过于复杂时，还可以绑定一个计算属性，也可以直接绑定一个`Object`类型的数据，或者使用类似计算属性的methods

在开发过程中，如果表达式较长或者逻辑复杂，应该尽可能地优先使用计算属性

使用`v-bind:style`可以给元素绑定内联样式，使用`:style`时，Vue.js会自动给特殊的CSS属性名称增加前缀

## 第五章

在一般情况下`v-cloak`是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用

`v-once`也是一个不需要表达式的指令，作用是定义它的元素或组建只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。

`v-show`是改变元素的CSS属性display，其只是简单的CSS属性切换，无聊条件真与否，都会被编译，`v-if`条件更适合不经常改变的场景，因为它切换开销相对较大

在HTML元素上监听事件的设计看似将DOM与JavaScript紧耦合，违背分离的原理，实际上通过HTML就可以知道调用的是哪个方法，将逻辑与DOM解耦，便于维护。最重要的是，当ViewModel销毁时，所有的事件处理都会自动删除，无须自己清理。

Vue提供了一个特殊的变量`$event`，用于访问原生DOM事件。

在'@'绑定的事件后加小圆点`.`再跟一个后缀来使用修饰符

- `.stop`
- `.prevent`:提交的事件不再重载页面
- `.capture`添加事件侦听器时使用事件捕获模式
- `.self`只当事件再该元素本身触发时触发回掉
- `.once`只触发一次

如果将js文件的引入写到`<head>`中，Vue实例将会无法创建，因为此时DOM还没被解析完成，除非通过异步活在事件DOMContentLoaded触发时再创建vue实例

## 第六章

使用`v-model`时，如果是中文输入法输入中文，一般在没有选定组词前，也就是在拼音阶段，Vue是不会更新数据的，当敲下汉字时候才会触发更新。如果总是希望实时更新，可以用`@input`来替代`v-model`‘

在输入框中，`v-model`默认是在input事件中同步输入框的数据，使用修饰符`.lazy`会转变为在change事件中同步

使用`.number`修饰符可以将输入转换为Number类型

使用`.trim`可以自动过滤输入的首尾空格

## 第七章

组件与实例类似，需要注册后才可以使用。注册有全局注册和局部注册两种。全局注册后，任何Vue实例都可以使用。

`template`的DOM 结构必须被一个元素包含

在Vue实例哦中，使用`components`选项可以局部注册组件，注册后的组件只有在该实例作用域下有效。组件中也可以使用`components`选项来注册组件，使组件可以嵌套

在组件中使用data时，其必须是一个函数，然后将数据`return`出去

JavaScript对象是引用关系，所以如果`return`出的对象引用了外部的一个对象，拿这个对象就是共享的，任何一方修改都会同步。

在组件中，使用选项`props`来声明需要从父级接收的数据，`props`的值可以是两种，一种是字符串数组，一种是对象

由于HTML特性不区分大小写，当使用DOM模板时，驼峰命名的props名称要转为短横线分隔命名，如果是字符串模板任然可以忽略这些限制。有时传递的数据是来自父级的胴体数据，这时候使用指令`v-bind`来绑定`props`的值，当父组件的数据发生变化时，也会传递给子组件

遇到父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意的修改和使用，这可以在组件data内再声明一个数据，引用父组件的`prop`

另外一种情况是`prop`作为需要被转变的原始值传入，这种情况用计算属性就可以了

在JavaScript中，对象和数组时引用类型，指向同一个内存空间，所以props时对象和数组时，在子组件内改变时会影响父组件的

一般当组件需要提供给其他人使用的时候，推荐都进行数据验证。验证的type类型可以是：

- String
- Number
- Boolean
- Object
- Array
- Function

type也可以是一个自定义构造器，使用instanceof检测

子组件用`$emit()`来触发事件，父组件用`$on()`来监听子组件的事件

在非组建通信中，推荐使用一个空的Vue实例作为中央事件总线，也就是一个中介。这种只需要在初始化bus获取一次，任何时间、任何组件就可以从中直接使用了

在子组件中，使用`this.$parent`可以直接访问该组件的父实例或组件，父组件也可以通过`this.$children`访问它所有的子组件，而且可以使用递归向上或向下无线访问，直到根实例或最内层的组件

使用特殊的属性`ref`来为子组件指定一个索引名称，在父组件模板中，子组件标签上使用`ref`制定一个名称，并在父组件内通过`this.$refs`来访问指定名称的子组件

props传递数据、events触发事件和slot内容分发就构成了Vue组件的3个API来源，再复杂的组件也是由这3部分构成的

父组件模板的内容实在父组件作用域内编译，子组件模板的内容是在子组件作用域内编译

如果没有指定默认的匿名slot，父组件内多余的内容片段都将被抛弃

可以使用`$slots`来访问slot分发的内容

组件的模板一般是在template选项内定义的，Vue提供了一个内联模板功能，再使用组件时，给组件标签使用`inline-template`特性，组件就会把它的内容当作模板，而不是把它当内容分发，这让模板更灵活

使用特殊的元素`<component>`来动态的挂载不同的组件，使用is特性来选择要挂载的组件

Vue提供了`Vue.extend`和`$mount`两个方法来手动挂载一个实例