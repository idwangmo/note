# 第一章

Java特性：

1. 简单性
2. 面向对象
3. 网络技能
4. 健壮性
5. 安全性
6. 体系结构中立
7. 可移植性
8. 解释型
9. 高性能
10. 多线程
11. 动态性

面向对象是一种程序设计技术。它将重点放在数据和对象的接口上。

及时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用。及时编译器知道哪些类已经加载。如果基于当前加载的类集，且特定的函数不被覆盖的话就可以内嵌。必要时，还可以撤销优化。

Java是一种程序设计语言，XML使用描述数据的方式。

# 第三章

Java对大小写敏感。

关键字public称为访问修饰符，它用于控制程序的其他部分对这段代码的访问级别。

Java中类名必须以字母开头，后面可以跟字母和数字的任意组合，长度上基本没有限制，但是不能使用Java保留字作为类名。源代码的类名必须与公共类型的名字相同，并用`.java`作为扩展名。

每个Java应用程序都必须有一个main方法，格式：

```java
public class ClassName {
    public static void main(String[] args) {
        programa statements
    }
}
```

Java调用的语法：

```java
object.method(parameters)
```

在Java中，可以没有参数，也可以有一个或多个参数，对于一个方法，即使没有参数也需要使用空括号。

## 数据类型

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8个基本类型，其中有4中整型、2中浮点类型、一种用于表示Unicode编码的字符型char和一种用于表示诊治的boolean类型。

 ![Java整型](..\image\CoreJava\Java整型.png)

在Java中，整型的范围与运行Java代码的机器无关。长整型数值有一个后缀L，十六进制数值有一个前缀`0x`，八进制有一个前缀`O`。Java7开始可以为数值字面量下面加下划线如`1_000_000`表示一百万。加上前缀`0b`就可以写二进制数。

 ![浮点类型](..\image\CoreJava\浮点类型.png)

float类型的数值有一个后缀F，没有后缀F的浮点数值默认为double类型。

便是溢出和出错的三个特殊的浮点数值：

* 正无穷大	`Double.POSITIVE_INFINITY`
* 负无穷大`Double.NEGATIVE_INFINITY`
* NaN（不是一个数字）`Double.NaN`

浮点数不适合用于禁止出现舍入误差的金融计算中，其主要原因是浮点数值采用和二进制系统表示，而在二进制系统中无法精确的表示分数1/10。若果需要在计算中不含有任何舍入误差，就应该使用BigDecimal类

char类型用于表示单个字符，通常用来表示字符常量。

代码点是指与一个编码表中的某个字符对应的代码值。第一个代码级别称为基本的多语言级别，代码点从U+0000到U+FFFF，其余的16个附加级别，代码点从U+10000到U+10FFFF，其中包括了一些辅助字符。

强烈建议不要在程序中使用char类型，除非确实需要对UTF-16代码单元进行操作。最好将需要处理的字符串用抽象数据类型表示。

## 变量

逐一声明每一个变量可以提高程序的可读性。

在声明一个变量之后，必须用赋值语句对变量进行显示初始化，千万不要使用未初始化的变量。Java中可以将声明放在代码的任何地方。

关键字final表示这个变量只能被赋值一次，一旦被赋值之后，就不能够再更改了。习惯上，常量名使用全大写。

在Java中，通常希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，可以使用关键字`static final`进行修饰。

整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大会NaN结果。

在默认情况下，虚拟机设计者运行将中间计算结果采用扩展的精度，但是对于使用`strictfp`关键字标记的方法必须使用严格的浮点计算来产生理想的结果。

`>>>`运算符将用0填充高位；`>>`运算符用符号位填充高位。

在Math类中，为了达到最快性能，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可以预测的结果比运行速度更重要的话，那么久应该使用StrictMath类。

 ![数值之间的合法转换](..\image\CoreJava\数值之间的合法转换.png)

隐式类型转换：

* 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型
* 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型
* 否则，若果其中一个操作数是long类型，另一个操作数将会转换为long类型
* 否则，两个操作数都将被转换为int类型

强制类型转换（显示类型转换）：

```java
dounle x = 9.997;
int nx = (int) x;
```

如果想对浮点数进行舍入计算，以便得到最接近的整数，那就需要使用`Math.round`方法。

round方法返回的结果为long类型，由于存在信息丢失的可能性，所有只有显示的强制类型转换才能够将long类型转换成int类型。

如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。不要在boolean类型与任何数值类型枝江进行强制类型转换，这样可以防止发生错误。

将布尔类型转换为数值类型：

``` java
b? 1:0
```

## 字符串

String类的substring方法可以从一个较大的字符串提取出一个子串。substring方法的第二个参数是不想复制的第一个位置。优点：容易计算子串长度。

Java语言运行使用`+`号连接两个字符串。

String类没有提供用于修改字符串的方法，并且其还是final类。不可变字符串的优点：编译器可以让字符串共享。如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。Java的设计者认为共享带来的高效率远远胜过提取、拼接字符串带来的低效率。

可以使用equals方法检测两个字符串是否相等。如`s.quals(t)`。要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。

**使用`==`运算符只能够确定两个字符串是否放置在同一个位置上。**

实际上只有字符串常量是共享的，而`+`或`substring`等操作产生的结果并不是共享的。

空串是一个Java对象，有自己的串长度和内容。不过String变量还可以存放一个特殊的值，名为null，这表示没有任何对象与该变量关联。

大多数常用的Unicode字符使用一个代码单元就可以表示，而辅助字符需要一对代码单元表示。length方法将返回采用UTF-16编码表示的给定字符串所需的代码单元数量。

StringBuilder类的前身是StringBuffer，其效率稍低，但允许采用多线程方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑，则应该用StringBuilder替代它，这两个类的API是相同的。

## 输入与输出

`System.in`标准输入

`System.out`标准输出

`System.error`标准错误

控制台读取输入：

1. 首先需要构造一个Scanner对象，并与“标准输入流”System.in关联。`Scanner in = new Scanner(System.in);`
2. 使用Scanner类的各种方法实现输入操作

因为输入是可见的，所以Scanner类不适用于从控制台读取密码。

可以使用s转换符格式化任意的对象，对于实现了Formattable接口的对象都将调用formatTo方法；否则将调用toString方法，他可以将对象转换为字符串。

许多格式化规则是本地环境特有的。

 ![格式说明符语法](..\image\CoreJava\格式说明符语法.png)

要想对文件进行读取，就需要一个用File对象构造一个Scanner对象。

要想写入文件，就需要构造一个PrintWriter对象。在构造其中，只需要提供文件名。

如果用一个不存在的文件构造一个Scanner，或者用一个不能被创建的文件名构造一个PrintWriter，那么就会发生异常。

## 控制流程

不能在嵌套的两个块中声明同名的变量。

在Java中，条件语句的格式为：

```java
if (condition) {
  statement;
}

或
if (condition){
    statement;
} else {
    statement;
}
```

while循环：

```java
while (condition){
    statement;
}
```

do/while循环：

```java
do statement while(condition);
```

for循环的语句中3个部分应该对同一个计数器变量进行初始化、检测和更新。

```java
for（循环变量；判断条件；改变内容）
```

如歌哦在for语句内部定义一个变量，这个变量就不能在循环体之外使用。

在switch语句中，如果没有相匹配的case标签，而有default子句，就执行这个子句。

case标签可以是：char、byte、short、int、及其包装器类型，枚举常量及字符串字面值

使用break跳出这一层的循环，使用continue继续下一次循环。使用带标签的break语句可以跳出多重嵌套循环。continue语句将控制转移到最内层循环的首部。

还有一种带标签的continue语句，将跳到与标签匹配的循环首部。

for-each循环，可以用来依次处理数组中的每个元素而不必为指定下标值而分心。

```java
for(variable :collection) statement
```

第一一个变量用于暂存集合中的每一个元素，并执行相应的语句。collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象。for-each循环语句的变量将会遍历数组中的每个元素，而不需要使用下标值。

## 数组

数组是一种数据结构，用来存储同一类型值的集合。通过一个整型下标可以访问数组中的没一个值。使用new运算符创建数组。创建一个数字数组时，所有元素都初始化为0，boolean数组的元素会初始化为false。对象数组的元素则会初始化为一个null。

数组拷贝时，如果长度小于原始数组的长度，则只拷贝最前面的数据元素。

`Arrays.sort(a)`这个方法使用了优化的快速排序算法。

`Math.random`方法将返回一个0到1（不包含1）的随机浮点数。

单层的for each循环语句不能自动处理二维数组的每一个元素，其是按照行进行处理的，也就是一维数组处理的。

Java实际上是没有多维素组，只有一维数组，多维数组被解释为”数组的数组“

# 第四章 对象与类

面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

只要对象能够满足要求，就不必关系其功能的具体实现。

封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象的数据称为实例域，操作数据的过程称为方法。

对象的三个主要特征：

* 对象的行为
* 对象的状态
* 对象的标示

对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。

类之间的关系：

* 依赖（“uses-a“）：如果一个类的方法操作另一个类的对象，我们就说一个类依赖于另一个类
* 聚合（”has-a“）：类A的对象包含类B的对象
* 基础（“is-a”）

要想使用对象，就必须首先构造对象，并制定其初始状态，然后对对象应用方法。

在Java语言程序设计语言中，使用构造器构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。

一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作的返回值也是一个引用。在Java中，必须使用clone方法获得对象的完整拷贝。

get方法仅仅查看并返回对象的状态，而set和add方法却对对象的状态进行修改。对实例域做出的修改方法称为更改器方法，仅访问实例域而不进行修改的方法称为访问器方法。

类的定义形式：

```java
class ClassName {
    field;
    constructor;
    method;
}
```

在一个源文件中，只能有一个公有类，但是可以有人要数目的非公有类。

类通常包括类型属于某个类型的实例域。

在构造类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。

构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。

构造器：

* 构造器与类名相同
* 每个类可以有一个以上构造器
* 构造器可以有0个，1个或多个参数
* 构造器没有返回值
* 构造器总是伴随着new操作一起使用

不要在构造器中定义与实例域重名的局部变量。

在每一个方法中，关键字this表示隐式参数。

有些时候，需要获得或设置实例域的值。应该提供：

* 一个私有的数据域
* 一个公有的域范围器方法
* 一个公有的域更改器方法。

更改器方法和可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。

一个方法可以访问所属类的所有对象的私有数据。

应该将所有的数据域都设置为私有的。

final修饰符大都应用于基本类型域，或不可变类的域。

最好不要将域设计为public，但是公有常量却没有问题。

静态方法不能操作对象，所以不能在静态方法中访问实例域，但是静态方法可以访问自身类中的静态域。

使用静态方法的情况：

* 一个方法不需要访问对象状态，其所需要参数都是通过显式参数提供
* 一个方法只需要访问类的静态域

按值调用表示方法接受的是调用者提供的值。而按引用调用表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。Java程序设计语言总是按值调用。

方法参数共有两种类型：

* 基本数据类型
* 对象引用

java程序设计语言对对象采用的不是值调用，实际上，对象引用进行的是值传递。

方法参数使用的情况：

* 一个方法不能修改一个基本数据类型的参数
* 一个方法可以修改一个变量的状态
* 一个方法不能让对象参数引用一个新对象

自动默认值：数值为0，布尔值为false，对象引用为null。如果不明确地对域进行初始化，就会银行程序代码的可读性。

如果在编写的一个类的时候没有编写构造器，那么系统就会提供一个无参数构造器，这个构造器将所有的实例域设置为默认值。

首先运行初始化块，然后才运行构造器主体。

finalize方法将在垃圾回收器清除对象之前调用。回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。

如果某个资源需要在在使用完后立刻被关闭，那么久需要由人工来管理。对象用完时，可以应用一个close方法来完成相应的清理操作。

类的设计技巧：

1. 一定要保证数据私有
2. 一定要对数据初始化
3. 不要在类中使用过多的基本类型
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解
6. 类名和方法名要能够体现它们的职责

# 继承

在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。

“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

调用过程的描述：

1. 编译器查看对象的声明类型和方法名。
2. 编译器查看调用方法时提供的参数类型。
3. 若果是private方法，static方法，final方法或者构造器，那么编译器可以准确地知道应该调用哪个方法，我们将这种调用方式称为静态绑定。
4. 当程序运行，并且采用动态绑定的调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类方法。


在早期的Java中，有些程序员为了避免动态绑定带来的系统开销而使用final关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，而这个过程称为内联。

如果方法很短、被频繁调用且没有真正的被覆盖，那么即时编译器就会将这个方法进行内联处理。

在进行类型转换之前，先查看一下是否能够成功的地转换。这个过程简单的使用instanceof运算符就可以实现。

只能在继承层次内进行类型转换，在将超类转换成子类之前，应该使用instanceof进行检查。

扩展抽象类有两种选择：

* 在子类定义中定义部分抽象方法或抽象方法也不定义，这样必须将子类也标记为抽象类
* 定义全部抽象方法，这样一来，子类就不是抽象的了

类即使不含抽象方法，也可以将类声明为抽象类。

四个访问修饰符：

* 仅对本类可见——private
* 对所有类可见——public
* 对本包和所有子类可见——protected
* 对本包可见——默认，不需要修饰符

在java中，只有基本类型不是对象。所有的数组类型，不管是数组对象还是基本类型的数组都扩展于Object类。在子类中定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。

java语言规范要求equals方法具有下面特性：

1. 自反性
2. 对称性
3. 传递性
4. 一致性
5. 对任意非空引用x，x.equals(null)应该返回false

如果子类能够拥有自己的相等概念，则对称性需求将强制采用getClass进行检测。

如果由超类决定相等的概念，那么就可以使instanceof进行检测，这样可以在不同子类的对象之间进行相等比较。

散列码是由对象导出的一个整型值。hashCode方法应该返回一个整型值，并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。

鉴于兼容性的考虑，编译器在对类型转换进行检查之后，如果没有发现违反规则的现象，就将所有的类型化数组列表转换成原始ArrayList对象。

一旦能确保不会造成严重后果，可以用`@SuppressWarnings('unchecked')`标注来标记这个变量能接受的类型转换。

对象包装器包装类是不可变的，即一旦构造了包装器，就不许更改包装在其中的值。