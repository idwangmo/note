# 第一章 Python数据模型

自Python 2.6 开始，`namedtuple`就加入到 Python 里，用以构建只有少数属性但是没有方法的对象，比如数据库条目。

通过实现特殊的方法来利用Python数据模型的好处：

* 不必去记住标准操作的名称
* 可以更加方便的利用标准库

迭代通常是隐式的，譬如说一个集合类型没有实现` __contains__ `方法，那么` in` 运算符就会按顺序做一次迭代搜索。

通常你的代码无需直接使用特殊方法。除非有大量的元编程存在，直接调用特殊方法的频率应该远远低于你去实现它们的次数。

`__repr__` 所返回的字符串应该准确、无歧义，并且尽可能表达出如何用代码创建出这个被打印的对象。

如果你只想实现这两个特殊方法中的一个，`__repr__` 是更好的选择，因为如果一个对象
没有` __str__` 函数，而 Python 又需要调用它的时候，解释器会用 `__repr__` 作为替代。

Python 对象的一个基本要求就是它得有合理的字符串表示形式

# 第二章 序列构成的数组

容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。

生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。

元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。

元组拆包可以应用到任何可迭代对象上，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。

对于元祖的三个教训：

* 不要把可变对象放在元组里面。
* 增量赋值不是一个原子操作。我们刚才也看到了，它虽然抛出了异常，但还是完成了操作。
* 查看 Python 的字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。

`list.sort` 方法会就地排序列表，也就是说不会把原列表复制一份。

如果一个函数或者方法对对象进行的是就地改动，那它就应该返回` None`，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。

